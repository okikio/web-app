var camelToDashMap = new Map();
function camelToDash(str) {
  var result = camelToDashMap.get(str);

  if (result === undefined) {
    result = str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    camelToDashMap.set(str, result);
  }

  return result;
}
function pascalToDash(str) {
  return camelToDash(str.replace(/((?!([A-Z]{2}|^))[A-Z])/g, '-$1'));
}
function shadyCSS(fn, fallback) {
  var shady = window.ShadyCSS;
  /* istanbul ignore next */

  if (shady && !shady.nativeShadow) {
    return fn(shady);
  }

  return fallback;
}
function stringifyElement(element) {
  var tagName = String(element.tagName).toLowerCase();
  return "<".concat(tagName, ">");
}
var IS_IE = 'ActiveXObject' in window;

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

var defaultTransform = function defaultTransform(v) {
  return v;
};

var objectTransform = function objectTransform(value) {
  if (_typeof(value) !== 'object') {
    throw TypeError("Assigned value must be an object: ".concat(typeof v === "undefined" ? "undefined" : _typeof(v)));
  }

  return value && Object.freeze(value);
};

function property(value, connect) {
  var type = _typeof(value);

  var transform = defaultTransform;

  switch (type) {
    case 'string':
      transform = String;
      break;

    case 'number':
      transform = Number;
      break;

    case 'boolean':
      transform = Boolean;
      break;

    case 'function':
      transform = value;
      value = transform();
      break;

    case 'object':
      if (value) Object.freeze(value);
      transform = objectTransform;
      break;

    default:
      break;
  }

  return {
    get: function get(host) {
      var val = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : value;
      return val;
    },
    set: function set(host, val, oldValue) {
      return transform(val, oldValue);
    },
    connect: type !== 'object' && type !== 'undefined' ? function (host, key, invalidate) {
      if (host[key] === value) {
        var attrName = camelToDash(key);

        if (host.hasAttribute(attrName)) {
          var attrValue = host.getAttribute(attrName);
          host[key] = attrValue !== '' ? attrValue : true;
        }
      }

      return connect && connect(host, key, invalidate);
    } : connect
  };
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _typeof$1(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$1 = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof$1(obj);
}

function render(_get) {
  var customOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (typeof _get !== 'function') {
    throw TypeError("The first argument must be a function: ".concat(_typeof$1(_get)));
  }

  var options = _objectSpread({
    shadowRoot: true
  }, customOptions);

  var shadowRootInit = {
    mode: 'open'
  };

  if (_typeof$1(options.shadowRoot) === 'object') {
    Object.assign(shadowRootInit, options.shadowRoot);
  }

  return {
    get: function get(host) {
      var fn = _get(host);

      return function flush() {
        fn(host, options.shadowRoot ? host.shadowRoot : host);
      };
    },
    connect: function connect(host) {
      if (options.shadowRoot && !host.shadowRoot) {
        host.attachShadow(shadowRootInit);
      }
    },
    observe: function observe(host, fn) {
      fn();
    }
  };
}

var targets = new WeakMap();

function getListeners(target) {
  var listeners = targets.get(target);

  if (!listeners) {
    listeners = new Set();
    targets.set(target, listeners);
  }

  return listeners;
}

var queue = new Set();

var run = function run(fn) {
  return fn();
};

function execute() {
  try {
    queue.forEach(function (target) {
      try {
        getListeners(target).forEach(run);
        queue.delete(target);
      } catch (e) {
        queue.delete(target);
        throw e;
      }
    });
  } catch (e) {
    if (queue.size) execute();
    throw e;
  }
}

function dispatch(target) {
  if (!queue.size) {
    requestAnimationFrame(execute);
  }

  queue.add(target);
}
function subscribe(target, cb) {
  var listeners = getListeners(target);
  listeners.add(cb);
  dispatch(target);
  return function () {
    return listeners.delete(cb);
  };
}

var entries = new WeakMap();
function getEntry(target, key) {
  var targetMap = entries.get(target);

  if (!targetMap) {
    targetMap = new Map();
    entries.set(target, targetMap);
  }

  var entry = targetMap.get(key);

  if (!entry) {
    entry = {
      target: target,
      key: key,
      value: undefined,
      contexts: undefined,
      deps: undefined,
      state: 1,
      checksum: 0,
      observed: false
    };
    targetMap.set(key, entry);
  }

  return entry;
}

function calculateChecksum(entry) {
  var checksum = entry.state;

  if (entry.deps) {
    entry.deps.forEach(function (depEntry) {
      // eslint-disable-next-line no-unused-expressions
      depEntry.target[depEntry.key];
      checksum += depEntry.state;
    });
  }

  return checksum;
}

function dispatchDeep(entry) {
  if (entry.observed) dispatch(entry);
  if (entry.contexts) entry.contexts.forEach(dispatchDeep);
}

var context = null;
function get(target, key, getter) {
  var entry = getEntry(target, key);

  if (context === entry) {
    context = null;
    throw Error("Circular '".concat(key, "' get invocation in '").concat(stringifyElement(target), "'"));
  }

  if (context) {
    context.deps = context.deps || new Set();
    context.deps.add(entry);
  }

  if (context && (context.observed || context.contexts && context.contexts.size)) {
    entry.contexts = entry.contexts || new Set();
    entry.contexts.add(context);
  }

  var parentContext = context;
  context = entry;

  if (entry.checksum && entry.checksum === calculateChecksum(entry)) {
    context = parentContext;
    return entry.value;
  }

  if (entry.deps && entry.deps.size) {
    entry.deps.forEach(function (depEntry) {
      if (depEntry.contexts) depEntry.contexts.delete(entry);
    });
    entry.deps = undefined;
  }

  try {
    var nextValue = getter(target, entry.value);

    if (nextValue !== entry.value) {
      entry.state += 1;
      entry.value = nextValue;
      dispatchDeep(entry);
    }

    entry.checksum = calculateChecksum(entry);
    context = parentContext;
  } catch (e) {
    context = null;
    throw e;
  }

  return entry.value;
}
function set(target, key, setter, value) {
  if (context) {
    context = null;
    throw Error("Try to set '".concat(key, "' of '").concat(stringifyElement(target), "' in get call"));
  }

  var entry = getEntry(target, key);
  var newValue = setter(target, value, entry.value);

  if (newValue !== entry.value) {
    entry.state += 1;
    entry.value = newValue;
    dispatchDeep(entry);
  }
}
function invalidate(target, key, clearValue) {
  if (context) {
    context = null;
    throw Error("Try to invalidate '".concat(key, "' in '").concat(stringifyElement(target), "' get call"));
  }

  var entry = getEntry(target, key);
  entry.checksum = 0;
  dispatchDeep(entry);

  if (clearValue) {
    entry.value = undefined;
  }
}
function observe(target, key, fn) {
  var entry = getEntry(target, key);
  entry.observed = true;
  return subscribe(entry, fn);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof$2(call) === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _typeof$2(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$2 = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$2 = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof$2(obj);
}
/* istanbul ignore next */

try {
  process.env.NODE_ENV;
} catch (e) {
  var process = {
    env: {
      NODE_ENV: 'production'
    }
  };
} // eslint-disable-line


var defaultMethod = function defaultMethod(host, value) {
  return value;
};

function compile(Hybrid, descriptors) {
  Hybrid.hybrids = descriptors;
  Hybrid.callbacks = [];
  Object.keys(descriptors).forEach(function (key) {
    var desc = descriptors[key];

    var type = _typeof$2(desc);

    var config;

    if (type === 'function') {
      config = key === 'render' ? render(desc) : {
        get: desc
      };
    } else if (type !== 'object' || desc === null || Array.isArray(desc)) {
      config = property(desc);
    } else {
      config = {
        get: desc.get || defaultMethod,
        set: desc.set || !desc.get && defaultMethod || undefined,
        connect: desc.connect,
        observe: desc.observe
      };
    }

    Object.defineProperty(Hybrid.prototype, key, {
      get: function get$1() {
        return get(this, key, config.get);
      },
      set: config.set && function set$1(newValue) {
        set(this, key, config.set, newValue);
      },
      enumerable: true,
      configurable: process.env.NODE_ENV !== 'production'
    });

    if (config.connect) {
      Hybrid.callbacks.push(function (host) {
        return config.connect(host, key, function () {
          invalidate(host, key);
        });
      });
    }

    if (config.observe) {
      Hybrid.callbacks.push(function (host) {
        var lastValue;
        return observe(host, key, function () {
          var value = host[key];

          if (value !== lastValue) {
            config.observe(host, value, lastValue);
            lastValue = value;
          }
        });
      });
    }
  });
}

var disconnects = new WeakMap();

function defineElement(tagName, hybridsOrConstructor) {
  var type = _typeof$2(hybridsOrConstructor);

  if (type !== 'object' && type !== 'function') {
    throw TypeError("Second argument must be an object or a function: ".concat(type));
  }

  var CustomElement = window.customElements.get(tagName);

  if (type === 'function') {
    if (CustomElement !== hybridsOrConstructor) {
      return window.customElements.define(tagName, hybridsOrConstructor);
    }

    return CustomElement;
  }

  if (CustomElement) {
    if (CustomElement.hybrids === hybridsOrConstructor) {
      return CustomElement;
    }

    throw Error("Element '".concat(tagName, "' already defined"));
  }

  var Hybrid =
  /*#__PURE__*/
  function (_HTMLElement) {
    _inherits(Hybrid, _HTMLElement);

    function Hybrid() {
      _classCallCheck(this, Hybrid);

      return _possibleConstructorReturn(this, _getPrototypeOf(Hybrid).apply(this, arguments));
    }

    _createClass(Hybrid, [{
      key: "connectedCallback",
      value: function connectedCallback() {
        var callbacks = this.constructor.callbacks;
        var list = [];

        for (var index = 0; index < callbacks.length; index += 1) {
          var cb = callbacks[index](this);
          if (cb) list.push(cb);
        }

        disconnects.set(this, list);
      }
    }, {
      key: "disconnectedCallback",
      value: function disconnectedCallback() {
        var list = disconnects.get(this);

        for (var index = 0; index < list.length; index += 1) {
          list[index]();
        }
      }
    }], [{
      key: "name",
      get: function get() {
        return tagName;
      }
    }]);

    return Hybrid;
  }(_wrapNativeSuper(HTMLElement));

  compile(Hybrid, hybridsOrConstructor);
  customElements.define(tagName, Hybrid);
  return Hybrid;
}

function defineMap(elements) {
  return Object.keys(elements).reduce(function (acc, key) {
    var tagName = pascalToDash(key);
    acc[key] = defineElement(tagName, elements[key]);
    return acc;
  }, {});
}

function define() {
  if (_typeof$2(arguments.length <= 0 ? undefined : arguments[0]) === 'object') {
    return defineMap(arguments.length <= 0 ? undefined : arguments[0]);
  }

  return defineElement.apply(void 0, arguments);
}

function walk(node, fn) {
  var parentElement = node.parentElement || node.parentNode.host;

  while (parentElement) {
    var hybrids = parentElement.constructor.hybrids;

    if (hybrids && fn(hybrids)) {
      return parentElement;
    }

    parentElement = parentElement.parentElement || parentElement.parentNode && parentElement.parentNode.host;
  }

  return parentElement || null;
}

function parent(hybridsOrFn) {
  var fn = typeof hybridsOrFn === 'function' ? hybridsOrFn : function (hybrids) {
    return hybrids === hybridsOrFn;
  };
  return {
    get: function get(host) {
      return walk(host, fn);
    },
    connect: function connect(host, key, invalidate) {
      var target = host[key];

      if (target) {
        return invalidate;
      }

      return false;
    }
  };
}

function walk$1(node, fn, options) {
  var items = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  Array.from(node.children).forEach(function (child) {
    var hybrids = child.constructor.hybrids;

    if (hybrids && fn(hybrids)) {
      items.push(child);

      if (options.deep && options.nested) {
        walk$1(child, fn, options, items);
      }
    } else if (options.deep) {
      walk$1(child, fn, options, items);
    }
  });
  return items;
}

function children(hybridsOrFn) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    deep: false,
    nested: false
  };
  var fn = typeof hybridsOrFn === 'function' ? hybridsOrFn : function (hybrids) {
    return hybrids === hybridsOrFn;
  };
  return {
    get: function get(host) {
      return walk$1(host, fn, options);
    },
    connect: function connect(host, key, invalidate) {
      var observer = new MutationObserver(invalidate);
      observer.observe(host, {
        childList: true,
        subtree: !!options.deep
      });
      return function () {
        observer.disconnect();
      };
    }
  };
}

var map = new WeakMap();
var dataMap = {
  get: function get(key, defaultValue) {
    var value = map.get(key);
    if (value) return value;

    if (defaultValue) {
      map.set(key, defaultValue);
    }

    return defaultValue;
  },
  set: function set(key, value) {
    map.set(key, value);
    return value;
  }
};
function getTemplateEnd(node) {
  var data; // eslint-disable-next-line no-cond-assign

  while (node && (data = dataMap.get(node)) && data.endNode) {
    node = data.endNode;
  }

  return node;
}
function removeTemplate(target) {
  if (target.nodeType !== Node.TEXT_NODE) {
    var child = target.childNodes[0];

    while (child) {
      target.removeChild(child);
      child = target.childNodes[0];
    }
  } else {
    var data = dataMap.get(target);

    if (data.startNode) {
      var endNode = getTemplateEnd(data.endNode);
      var node = data.startNode;
      var lastNextSibling = endNode.nextSibling;

      while (node) {
        var nextSibling = node.nextSibling;
        node.parentNode.removeChild(node);
        node = nextSibling !== lastNextSibling && nextSibling;
      }
    }
  }
}

var arrayMap = new WeakMap();

function movePlaceholder(target, previousSibling) {
  var data = dataMap.get(target);
  var startNode = data.startNode;
  var endNode = getTemplateEnd(data.endNode);
  previousSibling.parentNode.insertBefore(target, previousSibling.nextSibling);
  var prevNode = target;
  var node = startNode;

  while (node) {
    var nextNode = node.nextSibling;
    prevNode.parentNode.insertBefore(node, prevNode.nextSibling);
    prevNode = node;
    node = nextNode !== endNode.nextSibling && nextNode;
  }
}

function resolveArray(host, target, value) {
  var lastEntries = arrayMap.get(target);
  var entries = value.map(function (item, index) {
    return {
      id: Object.prototype.hasOwnProperty.call(item, 'id') ? item.id : index,
      value: item,
      placeholder: null,
      available: true
    };
  });
  arrayMap.set(target, entries);

  if (lastEntries) {
    var ids = new Set();
    entries.forEach(function (entry) {
      return ids.add(entry.id);
    });
    lastEntries = lastEntries.filter(function (entry) {
      if (!ids.has(entry.id)) {
        removeTemplate(entry.placeholder);
        entry.placeholder.parentNode.removeChild(entry.placeholder);
        return false;
      }

      return true;
    });
  }

  var previousSibling = target;
  var lastIndex = value.length - 1;
  var data = dataMap.get(target);

  for (var index = 0; index < entries.length; index += 1) {
    var entry = entries[index];
    var matchedEntry = void 0;

    if (lastEntries) {
      for (var i = 0; i < lastEntries.length; i += 1) {
        if (lastEntries[i].available && lastEntries[i].id === entry.id) {
          matchedEntry = lastEntries[i];
          break;
        }
      }
    }

    var placeholder = void 0;

    if (matchedEntry) {
      matchedEntry.available = false;
      placeholder = matchedEntry.placeholder;

      if (placeholder.previousSibling !== previousSibling) {
        movePlaceholder(placeholder, previousSibling);
      }

      if (matchedEntry.value !== entry.value) {
        resolveValue(host, placeholder, entry.value);
      }
    } else {
      placeholder = document.createTextNode('');
      previousSibling.parentNode.insertBefore(placeholder, previousSibling.nextSibling);
      resolveValue(host, placeholder, entry.value);
    }

    previousSibling = getTemplateEnd(dataMap.get(placeholder).endNode || placeholder);
    if (index === 0) data.startNode = placeholder;
    if (index === lastIndex) data.endNode = previousSibling;
    entry.placeholder = placeholder;
  }

  if (lastEntries) {
    lastEntries.forEach(function (entry) {
      if (entry.available) {
        removeTemplate(entry.placeholder);
        entry.placeholder.parentNode.removeChild(entry.placeholder);
      }
    });
  }
}

function _typeof$3(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$3 = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$3 = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof$3(obj);
}
function resolveValue(host, target, value) {
  var type = Array.isArray(value) ? 'array' : _typeof$3(value);
  var data = dataMap.get(target, {});

  if (data.type !== type) {
    removeTemplate(target);
    if (type === 'array') arrayMap.delete(target);
    data = dataMap.set(target, {
      type: type
    });

    if (target.textContent !== '') {
      target.textContent = '';
    }
  }

  switch (type) {
    case 'function':
      value(host, target);
      break;

    case 'array':
      resolveArray(host, target, value);
      break;

    default:
      target.textContent = type === 'number' || value ? value : '';
  }
}

function _typeof$4(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$4 = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$4 = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof$4(obj);
}

var eventMap = new WeakMap();
function resolveEventListener(eventType) {
  return function (host, target, value, lastValue) {
    if (lastValue) {
      target.removeEventListener(eventType, eventMap.get(lastValue), lastValue.options !== undefined ? lastValue.options : false);
    }

    if (value) {
      if (typeof value !== 'function') {
        throw Error("Event listener must be a function: ".concat(_typeof$4(value)));
      }

      eventMap.set(value, value.bind(null, host));
      target.addEventListener(eventType, eventMap.get(value), value.options !== undefined ? value.options : false);
    }
  };
}

function _typeof$5(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$5 = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$5 = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof$5(obj);
}

function normalizeValue(value) {
  var set = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();

  if (Array.isArray(value)) {
    value.forEach(function (className) {
      return set.add(className);
    });
  } else if (value !== null && _typeof$5(value) === 'object') {
    Object.keys(value).forEach(function (key) {
      return value[key] && set.add(key);
    });
  } else {
    set.add(value);
  }

  return set;
}

var classMap = new WeakMap();
function resolveClassList(host, target, value) {
  var previousList = classMap.get(target) || new Set();
  var list = normalizeValue(value);
  classMap.set(target, list);
  list.forEach(function (className) {
    target.classList.add(className);
    previousList.delete(className);
  });
  previousList.forEach(function (className) {
    target.classList.remove(className);
  });
}

function _typeof$6(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$6 = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$6 = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof$6(obj);
}
var styleMap = new WeakMap();
function resolveStyle(host, target, value) {
  if (value === null || _typeof$6(value) !== 'object') {
    throw TypeError("Style value must be an object in ".concat(stringifyElement(target), ":"), value);
  }

  var previousMap = styleMap.get(target) || new Map();
  var nextMap = Object.keys(value).reduce(function (map, key) {
    var dashKey = camelToDash(key);
    var styleValue = value[key];

    if (!styleValue && styleValue !== 0) {
      target.style.removeProperty(dashKey);
    } else {
      target.style.setProperty(dashKey, styleValue);
    }

    map.set(dashKey, styleValue);
    previousMap.delete(dashKey);
    return map;
  }, new Map());
  previousMap.forEach(function (styleValue, key) {
    target.style[key] = '';
  });
  styleMap.set(target, nextMap);
}

function resolveProperty(attrName, propertyName, isSVG) {
  if (propertyName.substr(0, 2) === 'on') {
    var eventType = propertyName.substr(2);
    return resolveEventListener(eventType);
  }

  switch (attrName) {
    case 'class':
      return resolveClassList;

    case 'style':
      return resolveStyle;

    default:
      return function (host, target, value) {
        if (!isSVG && !(target instanceof SVGElement) && propertyName in target) {
          if (target[propertyName] !== value) {
            target[propertyName] = value;
          }
        } else if (value === false || value === undefined || value === null) {
          target.removeAttribute(attrName);
        } else {
          var attrValue = value === true ? '' : String(value);
          target.setAttribute(attrName, attrValue);
        }
      };
  }
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _typeof$7(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$7 = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof$7 = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof$7(obj);
}
/* istanbul ignore next */

try {
  process$1.env.NODE_ENV;
} catch (e) {
  var process$1 = {
    env: {
      NODE_ENV: 'production'
    }
  };
} // eslint-disable-line


var TIMESTAMP = Date.now();
var getPlaceholder = function getPlaceholder() {
  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  return "{{h-".concat(TIMESTAMP, "-").concat(id, "}}");
};
var PLACEHOLDER_REGEXP_TEXT = getPlaceholder('(\\d+)');
var PLACEHOLDER_REGEXP_EQUAL = new RegExp("^".concat(PLACEHOLDER_REGEXP_TEXT, "$"));
var PLACEHOLDER_REGEXP_ALL = new RegExp(PLACEHOLDER_REGEXP_TEXT, 'g');
var ATTR_PREFIX = "--".concat(TIMESTAMP, "--");
var ATTR_REGEXP = new RegExp(ATTR_PREFIX, 'g');
var preparedTemplates = new WeakMap();
/* istanbul ignore next */

function applyShadyCSS(template, tagName) {
  if (!tagName) return template;
  return shadyCSS(function (shady) {
    var map = preparedTemplates.get(template);

    if (!map) {
      map = new Map();
      preparedTemplates.set(template, map);
    }

    var clone = map.get(tagName);

    if (!clone) {
      clone = document.createElement('template');
      clone.content.appendChild(template.content.cloneNode(true));
      map.set(tagName, clone);
      var styles = clone.content.querySelectorAll('style');
      Array.from(styles).forEach(function (style) {
        var count = style.childNodes.length + 1;

        for (var i = 0; i < count; i += 1) {
          style.parentNode.insertBefore(document.createTextNode(getPlaceholder()), style);
        }
      });
      shady.prepareTemplate(clone, tagName.toLowerCase());
    }

    return clone;
  }, template);
}

function createSignature(parts, styles) {
  var signature = parts.reduce(function (acc, part, index) {
    if (index === 0) {
      return part;
    }

    if (parts.slice(index).join('').match(/^\s*<\/\s*(table|tr|thead|tbody|tfoot|colgroup)>/)) {
      return "".concat(acc, "<!--").concat(getPlaceholder(index - 1), "-->").concat(part);
    }

    return acc + getPlaceholder(index - 1) + part;
  }, '');

  if (styles) {
    signature += "<style>\n".concat(styles.join('\n/*------*/\n'), "\n</style>");
  }
  /* istanbul ignore if */


  if (IS_IE) {
    return signature.replace(/style\s*=\s*(["][^"]+["]|['][^']+[']|[^\s"'<>/]+)/g, function (match) {
      return "".concat(ATTR_PREFIX).concat(match);
    });
  }

  return signature;
}

function getPropertyName(string) {
  return string.replace(/\s*=\s*['"]*$/g, '').split(' ').pop();
}

function replaceComments(fragment) {
  var iterator = document.createNodeIterator(fragment, NodeFilter.SHOW_COMMENT, null, false);
  var node; // eslint-disable-next-line no-cond-assign

  while (node = iterator.nextNode()) {
    if (PLACEHOLDER_REGEXP_EQUAL.test(node.textContent)) {
      node.parentNode.insertBefore(document.createTextNode(node.textContent), node);
      node.parentNode.removeChild(node);
    }
  }
}

function createInternalWalker(context) {
  var node;
  return {
    get currentNode() {
      return node;
    },

    nextNode: function nextNode() {
      if (node === undefined) {
        node = context.childNodes[0];
      } else if (node.childNodes.length) {
        node = node.childNodes[0];
      } else if (node.nextSibling) {
        node = node.nextSibling;
      } else {
        node = node.parentNode.nextSibling;
      }

      return !!node;
    }
  };
}

function createExternalWalker(context) {
  return document.createTreeWalker(context, // eslint-disable-next-line no-bitwise
  NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT, null, false);
}
/* istanbul ignore next */


var createWalker = _typeof$7(window.ShadyDOM) === 'object' && window.ShadyDOM.inUse ? createInternalWalker : createExternalWalker;
var container = document.createElement('div');
function compileTemplate(rawParts, isSVG, styles) {
  var template = document.createElement('template');
  var parts = [];
  var signature = createSignature(rawParts, styles);
  if (isSVG) signature = "<svg>".concat(signature, "</svg>");
  /* istanbul ignore if */

  if (IS_IE) {
    template.innerHTML = signature;
  } else {
    container.innerHTML = "<template>".concat(signature, "</template>");
    template.content.appendChild(container.children[0].content);
  }

  if (isSVG) {
    var svgRoot = template.content.firstChild;
    template.content.removeChild(svgRoot);
    Array.from(svgRoot.childNodes).forEach(function (node) {
      return template.content.appendChild(node);
    });
  }

  replaceComments(template.content);
  var compileWalker = createWalker(template.content);
  var compileIndex = 0;

  var _loop = function _loop() {
    var node = compileWalker.currentNode;

    if (node.nodeType === Node.TEXT_NODE) {
      var text = node.textContent;

      if (!text.match(PLACEHOLDER_REGEXP_EQUAL)) {
        var results = text.match(PLACEHOLDER_REGEXP_ALL);

        if (results) {
          var currentNode = node;
          results.reduce(function (acc, placeholder) {
            var _acc$pop$split = acc.pop().split(placeholder),
                _acc$pop$split2 = _slicedToArray(_acc$pop$split, 2),
                before = _acc$pop$split2[0],
                next = _acc$pop$split2[1];

            if (before) acc.push(before);
            acc.push(placeholder);
            if (next) acc.push(next);
            return acc;
          }, [text]).forEach(function (part, index) {
            if (index === 0) {
              currentNode.textContent = part;
            } else {
              currentNode = currentNode.parentNode.insertBefore(document.createTextNode(part), currentNode.nextSibling);
            }
          });
        }
      }

      var equal = node.textContent.match(PLACEHOLDER_REGEXP_EQUAL);

      if (equal) {
        /* istanbul ignore else */
        if (!IS_IE) node.textContent = '';
        parts[equal[1]] = [compileIndex, resolveValue];
      }
    } else {
      /* istanbul ignore else */
      // eslint-disable-next-line no-lonely-if
      if (node.nodeType === Node.ELEMENT_NODE) {
        Array.from(node.attributes).forEach(function (attr) {
          var value = attr.value.trim();
          /* istanbul ignore next */

          var name = IS_IE ? attr.name.replace(ATTR_PREFIX, '') : attr.name;
          var equal = value.match(PLACEHOLDER_REGEXP_EQUAL);

          if (equal) {
            var propertyName = getPropertyName(rawParts[equal[1]]);
            parts[equal[1]] = [compileIndex, resolveProperty(name, propertyName, isSVG)];
            node.removeAttribute(attr.name);
          } else {
            var _results = value.match(PLACEHOLDER_REGEXP_ALL);

            if (_results) {
              var partialName = "attr__".concat(name);

              _results.forEach(function (placeholder, index) {
                var _placeholder$match = placeholder.match(PLACEHOLDER_REGEXP_EQUAL),
                    _placeholder$match2 = _slicedToArray(_placeholder$match, 2),
                    id = _placeholder$match2[1];

                parts[id] = [compileIndex, function (host, target, attrValue) {
                  var data = dataMap.get(target, {});
                  data[partialName] = (data[partialName] || value).replace(placeholder, attrValue == null ? '' : attrValue);

                  if (_results.length === 1 || index + 1 === _results.length) {
                    target.setAttribute(name, data[partialName]);
                    data[partialName] = undefined;
                  }
                }];
              });

              attr.value = '';
              /* istanbul ignore next */

              if (IS_IE && name !== attr.name) {
                node.removeAttribute(attr.name);
                node.setAttribute(name, '');
              }
            }
          }
        });
      }
    }

    compileIndex += 1;
  };

  while (compileWalker.nextNode()) {
    _loop();
  }

  return function updateTemplateInstance(host, target, args) {
    var data = dataMap.get(target, {
      type: 'function'
    });

    if (template !== data.template) {
      if (data.template || target.nodeType === Node.ELEMENT_NODE) removeTemplate(target);
      data.lastArgs = null;
      var fragment = document.importNode(applyShadyCSS(template, host.tagName).content, true);
      var renderWalker = createWalker(fragment);
      var clonedParts = parts.slice(0);
      var renderIndex = 0;
      var currentPart = clonedParts.shift();
      var markers = [];
      data.template = template;
      data.markers = markers;

      while (renderWalker.nextNode()) {
        var node = renderWalker.currentNode;

        if (node.nodeType === Node.TEXT_NODE) {
          /* istanbul ignore next */
          if (PLACEHOLDER_REGEXP_EQUAL.test(node.textContent)) {
            node.textContent = '';
          } else if (IS_IE) {
            node.textContent = node.textContent.replace(ATTR_REGEXP, '');
          }
        }

        while (currentPart && currentPart[0] === renderIndex) {
          markers.push([node, currentPart[1]]);
          currentPart = clonedParts.shift();
        }

        renderIndex += 1;
      }

      if (target.nodeType === Node.TEXT_NODE) {
        data.startNode = fragment.childNodes[0];
        data.endNode = fragment.childNodes[fragment.childNodes.length - 1];
        var previousChild = target;
        var child = fragment.childNodes[0];

        while (child) {
          target.parentNode.insertBefore(child, previousChild.nextSibling);
          previousChild = child;
          child = fragment.childNodes[0];
        }
      } else {
        target.appendChild(fragment);
      }
    }

    for (var index = 0; index < data.markers.length; index += 1) {
      var _data$markers$index = _slicedToArray(data.markers[index], 2),
          _node = _data$markers$index[0],
          marker = _data$markers$index[1];

      if (!data.lastArgs || data.lastArgs[index] !== args[index]) {
        marker(host, _node, args[index], data.lastArgs ? data.lastArgs[index] : undefined);
      }
    }

    if (target.nodeType !== Node.TEXT_NODE) {
      shadyCSS(function (shady) {
        if (host.shadowRoot) {
          if (data.lastArgs) {
            shady.styleSubtree(host);
          } else {
            shady.styleElement(host);
          }
        }
      });
    }

    data.lastArgs = args;
  };
}

var setCache = new Map();
function set$1(propertyName, value) {
  if (!propertyName) throw Error("Target property name missing: ".concat(propertyName));

  if (arguments.length === 2) {
    return function (host) {
      host[propertyName] = value;
    };
  }

  var fn = setCache.get(propertyName);

  if (!fn) {
    fn = function fn(host, _ref) {
      var target = _ref.target;
      host[propertyName] = target.value;
    };

    setCache.set(propertyName, fn);
  }

  return fn;
}
var promiseMap = new WeakMap();
function resolve(promise, placeholder) {
  var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 200;
  return function (host, target) {
    var timeout;

    if (placeholder) {
      timeout = setTimeout(function () {
        timeout = undefined;
        requestAnimationFrame(function () {
          placeholder(host, target);
        });
      }, delay);
    }

    promiseMap.set(target, promise);
    promise.then(function (template) {
      if (timeout) clearTimeout(timeout);

      if (promiseMap.get(target) === promise) {
        template(host, target);
        promiseMap.set(target, null);
      }
    });
  };
}

var helpers = /*#__PURE__*/Object.freeze({
  set: set$1,
  resolve: resolve
});

var PLACEHOLDER = getPlaceholder();
var SVG_PLACEHOLDER = getPlaceholder('svg');
var templatesMap = new Map();
var stylesMap = new WeakMap();
var methods = {
  define: function define$1(elements) {
    define(elements);
    return this;
  },
  key: function key(id) {
    this.id = id;
    return this;
  },
  style: function style() {
    for (var _len = arguments.length, styles = new Array(_len), _key = 0; _key < _len; _key++) {
      styles[_key] = arguments[_key];
    }

    stylesMap.set(this, styles);
    return this;
  }
};

function create(parts, args, isSVG) {
  var createTemplate = function createTemplate(host) {
    var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : host;
    var styles = stylesMap.get(createTemplate);
    var id = parts.join(PLACEHOLDER);
    if (styles) id += styles.join(PLACEHOLDER);
    if (isSVG) id += SVG_PLACEHOLDER;
    var render = templatesMap.get(id);

    if (!render) {
      render = compileTemplate(parts, isSVG, styles);
      templatesMap.set(id, render);
    }

    render(host, target, args);
  };

  return Object.assign(createTemplate, methods);
}

function html(parts) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }

  return create(parts, args);
}
function svg(parts) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }

  return create(parts, args, true);
}
Object.assign(html, helpers);
Object.assign(svg, helpers);

/*
 * anime.js v3.1.0
 * (c) 2019 Julian Garnier
 * Released under the MIT license
 * animejs.com
 */
// Defaults
var defaultInstanceSettings = {
  update: null,
  begin: null,
  loopBegin: null,
  changeBegin: null,
  change: null,
  changeComplete: null,
  loopComplete: null,
  complete: null,
  loop: 1,
  direction: 'normal',
  autoplay: true,
  timelineOffset: 0
};
var defaultTweenSettings = {
  duration: 1000,
  delay: 0,
  endDelay: 0,
  easing: 'easeOutElastic(1, .5)',
  round: 0
};
var validTransforms = ['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'skew', 'skewX', 'skewY', 'perspective']; // Caching

var cache = {
  CSS: {},
  springs: {}
}; // Utils

function minMax(val, min, max) {
  return Math.min(Math.max(val, min), max);
}

function stringContains(str, text) {
  return str.indexOf(text) > -1;
}

function applyArguments(func, args) {
  return func.apply(null, args);
}

var is = {
  arr: function (a) {
    return Array.isArray(a);
  },
  obj: function (a) {
    return stringContains(Object.prototype.toString.call(a), 'Object');
  },
  pth: function (a) {
    return is.obj(a) && a.hasOwnProperty('totalLength');
  },
  svg: function (a) {
    return a instanceof SVGElement;
  },
  inp: function (a) {
    return a instanceof HTMLInputElement;
  },
  dom: function (a) {
    return a.nodeType || is.svg(a);
  },
  str: function (a) {
    return typeof a === 'string';
  },
  fnc: function (a) {
    return typeof a === 'function';
  },
  und: function (a) {
    return typeof a === 'undefined';
  },
  hex: function (a) {
    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a);
  },
  rgb: function (a) {
    return /^rgb/.test(a);
  },
  hsl: function (a) {
    return /^hsl/.test(a);
  },
  col: function (a) {
    return is.hex(a) || is.rgb(a) || is.hsl(a);
  },
  key: function (a) {
    return !defaultInstanceSettings.hasOwnProperty(a) && !defaultTweenSettings.hasOwnProperty(a) && a !== 'targets' && a !== 'keyframes';
  }
}; // Easings

function parseEasingParameters(string) {
  var match = /\(([^)]+)\)/.exec(string);
  return match ? match[1].split(',').map(function (p) {
    return parseFloat(p);
  }) : [];
} // Spring solver inspired by Webkit Copyright Â© 2016 Apple Inc. All rights reserved. https://webkit.org/demos/spring/spring.js


function spring(string, duration) {
  var params = parseEasingParameters(string);
  var mass = minMax(is.und(params[0]) ? 1 : params[0], .1, 100);
  var stiffness = minMax(is.und(params[1]) ? 100 : params[1], .1, 100);
  var damping = minMax(is.und(params[2]) ? 10 : params[2], .1, 100);
  var velocity = minMax(is.und(params[3]) ? 0 : params[3], .1, 100);
  var w0 = Math.sqrt(stiffness / mass);
  var zeta = damping / (2 * Math.sqrt(stiffness * mass));
  var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
  var a = 1;
  var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;

  function solver(t) {
    var progress = duration ? duration * t / 1000 : t;

    if (zeta < 1) {
      progress = Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress));
    } else {
      progress = (a + b * progress) * Math.exp(-progress * w0);
    }

    if (t === 0 || t === 1) {
      return t;
    }

    return 1 - progress;
  }

  function getDuration() {
    var cached = cache.springs[string];

    if (cached) {
      return cached;
    }

    var frame = 1 / 6;
    var elapsed = 0;
    var rest = 0;

    while (true) {
      elapsed += frame;

      if (solver(elapsed) === 1) {
        rest++;

        if (rest >= 16) {
          break;
        }
      } else {
        rest = 0;
      }
    }

    var duration = elapsed * frame * 1000;
    cache.springs[string] = duration;
    return duration;
  }

  return duration ? solver : getDuration;
} // Basic steps easing implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function


function steps(steps) {
  if (steps === void 0) steps = 10;
  return function (t) {
    return Math.round(t * steps) * (1 / steps);
  };
} // BezierEasing https://github.com/gre/bezier-easing


var bezier = function () {
  var kSplineTableSize = 11;
  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

  function A(aA1, aA2) {
    return 1.0 - 3.0 * aA2 + 3.0 * aA1;
  }

  function B(aA1, aA2) {
    return 3.0 * aA2 - 6.0 * aA1;
  }

  function C(aA1) {
    return 3.0 * aA1;
  }

  function calcBezier(aT, aA1, aA2) {
    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
  }

  function getSlope(aT, aA1, aA2) {
    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
  }

  function binarySubdivide(aX, aA, aB, mX1, mX2) {
    var currentX,
        currentT,
        i = 0;

    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;

      if (currentX > 0.0) {
        aB = currentT;
      } else {
        aA = currentT;
      }
    } while (Math.abs(currentX) > 0.0000001 && ++i < 10);

    return currentT;
  }

  function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for (var i = 0; i < 4; ++i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);

      if (currentSlope === 0.0) {
        return aGuessT;
      }

      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }

    return aGuessT;
  }

  function bezier(mX1, mY1, mX2, mY2) {
    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
      return;
    }

    var sampleValues = new Float32Array(kSplineTableSize);

    if (mX1 !== mY1 || mX2 !== mY2) {
      for (var i = 0; i < kSplineTableSize; ++i) {
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
      }
    }

    function getTForX(aX) {
      var intervalStart = 0;
      var currentSample = 1;
      var lastSample = kSplineTableSize - 1;

      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
        intervalStart += kSampleStepSize;
      }

      --currentSample;
      var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
      var guessForT = intervalStart + dist * kSampleStepSize;
      var initialSlope = getSlope(guessForT, mX1, mX2);

      if (initialSlope >= 0.001) {
        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
      } else if (initialSlope === 0.0) {
        return guessForT;
      } else {
        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
      }
    }

    return function (x) {
      if (mX1 === mY1 && mX2 === mY2) {
        return x;
      }

      if (x === 0 || x === 1) {
        return x;
      }

      return calcBezier(getTForX(x), mY1, mY2);
    };
  }

  return bezier;
}();

var penner = function () {
  // Based on jQuery UI's implemenation of easing equations from Robert Penner (http://www.robertpenner.com/easing)
  var eases = {
    linear: function () {
      return function (t) {
        return t;
      };
    }
  };
  var functionEasings = {
    Sine: function () {
      return function (t) {
        return 1 - Math.cos(t * Math.PI / 2);
      };
    },
    Circ: function () {
      return function (t) {
        return 1 - Math.sqrt(1 - t * t);
      };
    },
    Back: function () {
      return function (t) {
        return t * t * (3 * t - 2);
      };
    },
    Bounce: function () {
      return function (t) {
        var pow2,
            b = 4;

        while (t < ((pow2 = Math.pow(2, --b)) - 1) / 11) {}

        return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - t, 2);
      };
    },
    Elastic: function (amplitude, period) {
      if (amplitude === void 0) amplitude = 1;
      if (period === void 0) period = .5;
      var a = minMax(amplitude, 1, 10);
      var p = minMax(period, .1, 2);
      return function (t) {
        return t === 0 || t === 1 ? t : -a * Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - p / (Math.PI * 2) * Math.asin(1 / a)) * (Math.PI * 2) / p);
      };
    }
  };
  var baseEasings = ['Quad', 'Cubic', 'Quart', 'Quint', 'Expo'];
  baseEasings.forEach(function (name, i) {
    functionEasings[name] = function () {
      return function (t) {
        return Math.pow(t, i + 2);
      };
    };
  });
  Object.keys(functionEasings).forEach(function (name) {
    var easeIn = functionEasings[name];
    eases['easeIn' + name] = easeIn;

    eases['easeOut' + name] = function (a, b) {
      return function (t) {
        return 1 - easeIn(a, b)(1 - t);
      };
    };

    eases['easeInOut' + name] = function (a, b) {
      return function (t) {
        return t < 0.5 ? easeIn(a, b)(t * 2) / 2 : 1 - easeIn(a, b)(t * -2 + 2) / 2;
      };
    };
  });
  return eases;
}();

function parseEasings(easing, duration) {
  if (is.fnc(easing)) {
    return easing;
  }

  var name = easing.split('(')[0];
  var ease = penner[name];
  var args = parseEasingParameters(easing);

  switch (name) {
    case 'spring':
      return spring(easing, duration);

    case 'cubicBezier':
      return applyArguments(bezier, args);

    case 'steps':
      return applyArguments(steps, args);

    default:
      return applyArguments(ease, args);
  }
} // Strings


function selectString(str) {
  try {
    var nodes = document.querySelectorAll(str);
    return nodes;
  } catch (e) {
    return;
  }
} // Arrays


function filterArray(arr, callback) {
  var len = arr.length;
  var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
  var result = [];

  for (var i = 0; i < len; i++) {
    if (i in arr) {
      var val = arr[i];

      if (callback.call(thisArg, val, i, arr)) {
        result.push(val);
      }
    }
  }

  return result;
}

function flattenArray(arr) {
  return arr.reduce(function (a, b) {
    return a.concat(is.arr(b) ? flattenArray(b) : b);
  }, []);
}

function toArray(o) {
  if (is.arr(o)) {
    return o;
  }

  if (is.str(o)) {
    o = selectString(o) || o;
  }

  if (o instanceof NodeList || o instanceof HTMLCollection) {
    return [].slice.call(o);
  }

  return [o];
}

function arrayContains(arr, val) {
  return arr.some(function (a) {
    return a === val;
  });
} // Objects


function cloneObject(o) {
  var clone = {};

  for (var p in o) {
    clone[p] = o[p];
  }

  return clone;
}

function replaceObjectProps(o1, o2) {
  var o = cloneObject(o1);

  for (var p in o1) {
    o[p] = o2.hasOwnProperty(p) ? o2[p] : o1[p];
  }

  return o;
}

function mergeObjects(o1, o2) {
  var o = cloneObject(o1);

  for (var p in o2) {
    o[p] = is.und(o1[p]) ? o2[p] : o1[p];
  }

  return o;
} // Colors


function rgbToRgba(rgbValue) {
  var rgb = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(rgbValue);
  return rgb ? "rgba(" + rgb[1] + ",1)" : rgbValue;
}

function hexToRgba(hexValue) {
  var rgx = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  var hex = hexValue.replace(rgx, function (m, r, g, b) {
    return r + r + g + g + b + b;
  });
  var rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  var r = parseInt(rgb[1], 16);
  var g = parseInt(rgb[2], 16);
  var b = parseInt(rgb[3], 16);
  return "rgba(" + r + "," + g + "," + b + ",1)";
}

function hslToRgba(hslValue) {
  var hsl = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(hslValue) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(hslValue);
  var h = parseInt(hsl[1], 10) / 360;
  var s = parseInt(hsl[2], 10) / 100;
  var l = parseInt(hsl[3], 10) / 100;
  var a = hsl[4] || 1;

  function hue2rgb(p, q, t) {
    if (t < 0) {
      t += 1;
    }

    if (t > 1) {
      t -= 1;
    }

    if (t < 1 / 6) {
      return p + (q - p) * 6 * t;
    }

    if (t < 1 / 2) {
      return q;
    }

    if (t < 2 / 3) {
      return p + (q - p) * (2 / 3 - t) * 6;
    }

    return p;
  }

  var r, g, b;

  if (s == 0) {
    r = g = b = l;
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }

  return "rgba(" + r * 255 + "," + g * 255 + "," + b * 255 + "," + a + ")";
}

function colorToRgb(val) {
  if (is.rgb(val)) {
    return rgbToRgba(val);
  }

  if (is.hex(val)) {
    return hexToRgba(val);
  }

  if (is.hsl(val)) {
    return hslToRgba(val);
  }
} // Units


function getUnit(val) {
  var split = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(val);

  if (split) {
    return split[1];
  }
}

function getTransformUnit(propName) {
  if (stringContains(propName, 'translate') || propName === 'perspective') {
    return 'px';
  }

  if (stringContains(propName, 'rotate') || stringContains(propName, 'skew')) {
    return 'deg';
  }
} // Values


function getFunctionValue(val, animatable) {
  if (!is.fnc(val)) {
    return val;
  }

  return val(animatable.target, animatable.id, animatable.total);
}

function getAttribute(el, prop) {
  return el.getAttribute(prop);
}

function convertPxToUnit(el, value, unit) {
  var valueUnit = getUnit(value);

  if (arrayContains([unit, 'deg', 'rad', 'turn'], valueUnit)) {
    return value;
  }

  var cached = cache.CSS[value + unit];

  if (!is.und(cached)) {
    return cached;
  }

  var baseline = 100;
  var tempEl = document.createElement(el.tagName);
  var parentEl = el.parentNode && el.parentNode !== document ? el.parentNode : document.body;
  parentEl.appendChild(tempEl);
  tempEl.style.position = 'absolute';
  tempEl.style.width = baseline + unit;
  var factor = baseline / tempEl.offsetWidth;
  parentEl.removeChild(tempEl);
  var convertedUnit = factor * parseFloat(value);
  cache.CSS[value + unit] = convertedUnit;
  return convertedUnit;
}

function getCSSValue(el, prop, unit) {
  if (prop in el.style) {
    var uppercasePropName = prop.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    var value = el.style[prop] || getComputedStyle(el).getPropertyValue(uppercasePropName) || '0';
    return unit ? convertPxToUnit(el, value, unit) : value;
  }
}

function getAnimationType(el, prop) {
  if (is.dom(el) && !is.inp(el) && (getAttribute(el, prop) || is.svg(el) && el[prop])) {
    return 'attribute';
  }

  if (is.dom(el) && arrayContains(validTransforms, prop)) {
    return 'transform';
  }

  if (is.dom(el) && prop !== 'transform' && getCSSValue(el, prop)) {
    return 'css';
  }

  if (el[prop] != null) {
    return 'object';
  }
}

function getElementTransforms(el) {
  if (!is.dom(el)) {
    return;
  }

  var str = el.style.transform || '';
  var reg = /(\w+)\(([^)]*)\)/g;
  var transforms = new Map();
  var m;

  while (m = reg.exec(str)) {
    transforms.set(m[1], m[2]);
  }

  return transforms;
}

function getTransformValue(el, propName, animatable, unit) {
  var defaultVal = stringContains(propName, 'scale') ? 1 : 0 + getTransformUnit(propName);
  var value = getElementTransforms(el).get(propName) || defaultVal;

  if (animatable) {
    animatable.transforms.list.set(propName, value);
    animatable.transforms['last'] = propName;
  }

  return unit ? convertPxToUnit(el, value, unit) : value;
}

function getOriginalTargetValue(target, propName, unit, animatable) {
  switch (getAnimationType(target, propName)) {
    case 'transform':
      return getTransformValue(target, propName, animatable, unit);

    case 'css':
      return getCSSValue(target, propName, unit);

    case 'attribute':
      return getAttribute(target, propName);

    default:
      return target[propName] || 0;
  }
}

function getRelativeValue(to, from) {
  var operator = /^(\*=|\+=|-=)/.exec(to);

  if (!operator) {
    return to;
  }

  var u = getUnit(to) || 0;
  var x = parseFloat(from);
  var y = parseFloat(to.replace(operator[0], ''));

  switch (operator[0][0]) {
    case '+':
      return x + y + u;

    case '-':
      return x - y + u;

    case '*':
      return x * y + u;
  }
}

function validateValue(val, unit) {
  if (is.col(val)) {
    return colorToRgb(val);
  }

  if (/\s/g.test(val)) {
    return val;
  }

  var originalUnit = getUnit(val);
  var unitLess = originalUnit ? val.substr(0, val.length - originalUnit.length) : val;

  if (unit) {
    return unitLess + unit;
  }

  return unitLess;
} // getTotalLength() equivalent for circle, rect, polyline, polygon and line shapes
// adapted from https://gist.github.com/SebLambla/3e0550c496c236709744


function getDistance(p1, p2) {
  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}

function getCircleLength(el) {
  return Math.PI * 2 * getAttribute(el, 'r');
}

function getRectLength(el) {
  return getAttribute(el, 'width') * 2 + getAttribute(el, 'height') * 2;
}

function getLineLength(el) {
  return getDistance({
    x: getAttribute(el, 'x1'),
    y: getAttribute(el, 'y1')
  }, {
    x: getAttribute(el, 'x2'),
    y: getAttribute(el, 'y2')
  });
}

function getPolylineLength(el) {
  var points = el.points;
  var totalLength = 0;
  var previousPos;

  for (var i = 0; i < points.numberOfItems; i++) {
    var currentPos = points.getItem(i);

    if (i > 0) {
      totalLength += getDistance(previousPos, currentPos);
    }

    previousPos = currentPos;
  }

  return totalLength;
}

function getPolygonLength(el) {
  var points = el.points;
  return getPolylineLength(el) + getDistance(points.getItem(points.numberOfItems - 1), points.getItem(0));
} // Path animation


function getTotalLength(el) {
  if (el.getTotalLength) {
    return el.getTotalLength();
  }

  switch (el.tagName.toLowerCase()) {
    case 'circle':
      return getCircleLength(el);

    case 'rect':
      return getRectLength(el);

    case 'line':
      return getLineLength(el);

    case 'polyline':
      return getPolylineLength(el);

    case 'polygon':
      return getPolygonLength(el);
  }
}

function setDashoffset(el) {
  var pathLength = getTotalLength(el);
  el.setAttribute('stroke-dasharray', pathLength);
  return pathLength;
} // Motion path


function getParentSvgEl(el) {
  var parentEl = el.parentNode;

  while (is.svg(parentEl)) {
    if (!is.svg(parentEl.parentNode)) {
      break;
    }

    parentEl = parentEl.parentNode;
  }

  return parentEl;
}

function getParentSvg(pathEl, svgData) {
  var svg = svgData || {};
  var parentSvgEl = svg.el || getParentSvgEl(pathEl);
  var rect = parentSvgEl.getBoundingClientRect();
  var viewBoxAttr = getAttribute(parentSvgEl, 'viewBox');
  var width = rect.width;
  var height = rect.height;
  var viewBox = svg.viewBox || (viewBoxAttr ? viewBoxAttr.split(' ') : [0, 0, width, height]);
  return {
    el: parentSvgEl,
    viewBox: viewBox,
    x: viewBox[0] / 1,
    y: viewBox[1] / 1,
    w: width / viewBox[2],
    h: height / viewBox[3]
  };
}

function getPath(path, percent) {
  var pathEl = is.str(path) ? selectString(path)[0] : path;
  var p = percent || 100;
  return function (property) {
    return {
      property: property,
      el: pathEl,
      svg: getParentSvg(pathEl),
      totalLength: getTotalLength(pathEl) * (p / 100)
    };
  };
}

function getPathProgress(path, progress) {
  function point(offset) {
    if (offset === void 0) offset = 0;
    var l = progress + offset >= 1 ? progress + offset : 0;
    return path.el.getPointAtLength(l);
  }

  var svg = getParentSvg(path.el, path.svg);
  var p = point();
  var p0 = point(-1);
  var p1 = point(+1);

  switch (path.property) {
    case 'x':
      return (p.x - svg.x) * svg.w;

    case 'y':
      return (p.y - svg.y) * svg.h;

    case 'angle':
      return Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;
  }
} // Decompose value


function decomposeValue(val, unit) {
  // const rgx = /-?\d*\.?\d+/g; // handles basic numbers
  // const rgx = /[+-]?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation
  var rgx = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation

  var value = validateValue(is.pth(val) ? val.totalLength : val, unit) + '';
  return {
    original: value,
    numbers: value.match(rgx) ? value.match(rgx).map(Number) : [0],
    strings: is.str(val) || unit ? value.split(rgx) : []
  };
} // Animatables


function parseTargets(targets) {
  var targetsArray = targets ? flattenArray(is.arr(targets) ? targets.map(toArray) : toArray(targets)) : [];
  return filterArray(targetsArray, function (item, pos, self) {
    return self.indexOf(item) === pos;
  });
}

function getAnimatables(targets) {
  var parsed = parseTargets(targets);
  return parsed.map(function (t, i) {
    return {
      target: t,
      id: i,
      total: parsed.length,
      transforms: {
        list: getElementTransforms(t)
      }
    };
  });
} // Properties


function normalizePropertyTweens(prop, tweenSettings) {
  var settings = cloneObject(tweenSettings); // Override duration if easing is a spring

  if (/^spring/.test(settings.easing)) {
    settings.duration = spring(settings.easing);
  }

  if (is.arr(prop)) {
    var l = prop.length;
    var isFromTo = l === 2 && !is.obj(prop[0]);

    if (!isFromTo) {
      // Duration divided by the number of tweens
      if (!is.fnc(tweenSettings.duration)) {
        settings.duration = tweenSettings.duration / l;
      }
    } else {
      // Transform [from, to] values shorthand to a valid tween value
      prop = {
        value: prop
      };
    }
  }

  var propArray = is.arr(prop) ? prop : [prop];
  return propArray.map(function (v, i) {
    var obj = is.obj(v) && !is.pth(v) ? v : {
      value: v
    }; // Default delay value should only be applied to the first tween

    if (is.und(obj.delay)) {
      obj.delay = !i ? tweenSettings.delay : 0;
    } // Default endDelay value should only be applied to the last tween


    if (is.und(obj.endDelay)) {
      obj.endDelay = i === propArray.length - 1 ? tweenSettings.endDelay : 0;
    }

    return obj;
  }).map(function (k) {
    return mergeObjects(k, settings);
  });
}

function flattenKeyframes(keyframes) {
  var propertyNames = filterArray(flattenArray(keyframes.map(function (key) {
    return Object.keys(key);
  })), function (p) {
    return is.key(p);
  }).reduce(function (a, b) {
    if (a.indexOf(b) < 0) {
      a.push(b);
    }

    return a;
  }, []);
  var properties = {};

  var loop = function (i) {
    var propName = propertyNames[i];
    properties[propName] = keyframes.map(function (key) {
      var newKey = {};

      for (var p in key) {
        if (is.key(p)) {
          if (p == propName) {
            newKey.value = key[p];
          }
        } else {
          newKey[p] = key[p];
        }
      }

      return newKey;
    });
  };

  for (var i = 0; i < propertyNames.length; i++) loop(i);

  return properties;
}

function getProperties(tweenSettings, params) {
  var properties = [];
  var keyframes = params.keyframes;

  if (keyframes) {
    params = mergeObjects(flattenKeyframes(keyframes), params);
  }

  for (var p in params) {
    if (is.key(p)) {
      properties.push({
        name: p,
        tweens: normalizePropertyTweens(params[p], tweenSettings)
      });
    }
  }

  return properties;
} // Tweens


function normalizeTweenValues(tween, animatable) {
  var t = {};

  for (var p in tween) {
    var value = getFunctionValue(tween[p], animatable);

    if (is.arr(value)) {
      value = value.map(function (v) {
        return getFunctionValue(v, animatable);
      });

      if (value.length === 1) {
        value = value[0];
      }
    }

    t[p] = value;
  }

  t.duration = parseFloat(t.duration);
  t.delay = parseFloat(t.delay);
  return t;
}

function normalizeTweens(prop, animatable) {
  var previousTween;
  return prop.tweens.map(function (t) {
    var tween = normalizeTweenValues(t, animatable);
    var tweenValue = tween.value;
    var to = is.arr(tweenValue) ? tweenValue[1] : tweenValue;
    var toUnit = getUnit(to);
    var originalValue = getOriginalTargetValue(animatable.target, prop.name, toUnit, animatable);
    var previousValue = previousTween ? previousTween.to.original : originalValue;
    var from = is.arr(tweenValue) ? tweenValue[0] : previousValue;
    var fromUnit = getUnit(from) || getUnit(originalValue);
    var unit = toUnit || fromUnit;

    if (is.und(to)) {
      to = previousValue;
    }

    tween.from = decomposeValue(from, unit);
    tween.to = decomposeValue(getRelativeValue(to, from), unit);
    tween.start = previousTween ? previousTween.end : 0;
    tween.end = tween.start + tween.delay + tween.duration + tween.endDelay;
    tween.easing = parseEasings(tween.easing, tween.duration);
    tween.isPath = is.pth(tweenValue);
    tween.isColor = is.col(tween.from.original);

    if (tween.isColor) {
      tween.round = 1;
    }

    previousTween = tween;
    return tween;
  });
} // Tween progress


var setProgressValue = {
  css: function (t, p, v) {
    return t.style[p] = v;
  },
  attribute: function (t, p, v) {
    return t.setAttribute(p, v);
  },
  object: function (t, p, v) {
    return t[p] = v;
  },
  transform: function (t, p, v, transforms, manual) {
    transforms.list.set(p, v);

    if (p === transforms.last || manual) {
      var str = '';
      transforms.list.forEach(function (value, prop) {
        str += prop + "(" + value + ") ";
      });
      t.style.transform = str;
    }
  }
}; // Set Value helper

function setTargetsValue(targets, properties) {
  var animatables = getAnimatables(targets);
  animatables.forEach(function (animatable) {
    for (var property in properties) {
      var value = getFunctionValue(properties[property], animatable);
      var target = animatable.target;
      var valueUnit = getUnit(value);
      var originalValue = getOriginalTargetValue(target, property, valueUnit, animatable);
      var unit = valueUnit || getUnit(originalValue);
      var to = getRelativeValue(validateValue(value, unit), originalValue);
      var animType = getAnimationType(target, property);
      setProgressValue[animType](target, property, to, animatable.transforms, true);
    }
  });
} // Animations


function createAnimation(animatable, prop) {
  var animType = getAnimationType(animatable.target, prop.name);

  if (animType) {
    var tweens = normalizeTweens(prop, animatable);
    var lastTween = tweens[tweens.length - 1];
    return {
      type: animType,
      property: prop.name,
      animatable: animatable,
      tweens: tweens,
      duration: lastTween.end,
      delay: tweens[0].delay,
      endDelay: lastTween.endDelay
    };
  }
}

function getAnimations(animatables, properties) {
  return filterArray(flattenArray(animatables.map(function (animatable) {
    return properties.map(function (prop) {
      return createAnimation(animatable, prop);
    });
  })), function (a) {
    return !is.und(a);
  });
} // Create Instance


function getInstanceTimings(animations, tweenSettings) {
  var animLength = animations.length;

  var getTlOffset = function (anim) {
    return anim.timelineOffset ? anim.timelineOffset : 0;
  };

  var timings = {};
  timings.duration = animLength ? Math.max.apply(Math, animations.map(function (anim) {
    return getTlOffset(anim) + anim.duration;
  })) : tweenSettings.duration;
  timings.delay = animLength ? Math.min.apply(Math, animations.map(function (anim) {
    return getTlOffset(anim) + anim.delay;
  })) : tweenSettings.delay;
  timings.endDelay = animLength ? timings.duration - Math.max.apply(Math, animations.map(function (anim) {
    return getTlOffset(anim) + anim.duration - anim.endDelay;
  })) : tweenSettings.endDelay;
  return timings;
}

var instanceID = 0;

function createNewInstance(params) {
  var instanceSettings = replaceObjectProps(defaultInstanceSettings, params);
  var tweenSettings = replaceObjectProps(defaultTweenSettings, params);
  var properties = getProperties(tweenSettings, params);
  var animatables = getAnimatables(params.targets);
  var animations = getAnimations(animatables, properties);
  var timings = getInstanceTimings(animations, tweenSettings);
  var id = instanceID;
  instanceID++;
  return mergeObjects(instanceSettings, {
    id: id,
    children: [],
    animatables: animatables,
    animations: animations,
    duration: timings.duration,
    delay: timings.delay,
    endDelay: timings.endDelay
  });
} // Core


var activeInstances = [];
var pausedInstances = [];
var raf;

var engine = function () {
  function play() {
    raf = requestAnimationFrame(step);
  }

  function step(t) {
    var activeInstancesLength = activeInstances.length;

    if (activeInstancesLength) {
      var i = 0;

      while (i < activeInstancesLength) {
        var activeInstance = activeInstances[i];

        if (!activeInstance.paused) {
          activeInstance.tick(t);
        } else {
          var instanceIndex = activeInstances.indexOf(activeInstance);

          if (instanceIndex > -1) {
            activeInstances.splice(instanceIndex, 1);
            activeInstancesLength = activeInstances.length;
          }
        }

        i++;
      }

      play();
    } else {
      raf = cancelAnimationFrame(raf);
    }
  }

  return play;
}();

function handleVisibilityChange() {
  if (document.hidden) {
    activeInstances.forEach(function (ins) {
      return ins.pause();
    });
    pausedInstances = activeInstances.slice(0);
    anime.running = activeInstances = [];
  } else {
    pausedInstances.forEach(function (ins) {
      return ins.play();
    });
  }
}

if (typeof document !== 'undefined') {
  document.addEventListener('visibilitychange', handleVisibilityChange);
} // Public Instance


function anime(params) {
  if (params === void 0) params = {};
  var startTime = 0,
      lastTime = 0,
      now = 0;
  var children,
      childrenLength = 0;
  var resolve = null;

  function makePromise(instance) {
    var promise = window.Promise && new Promise(function (_resolve) {
      return resolve = _resolve;
    });
    instance.finished = promise;
    return promise;
  }

  var instance = createNewInstance(params);
  var promise = makePromise(instance);

  function toggleInstanceDirection() {
    var direction = instance.direction;

    if (direction !== 'alternate') {
      instance.direction = direction !== 'normal' ? 'normal' : 'reverse';
    }

    instance.reversed = !instance.reversed;
    children.forEach(function (child) {
      return child.reversed = instance.reversed;
    });
  }

  function adjustTime(time) {
    return instance.reversed ? instance.duration - time : time;
  }

  function resetTime() {
    startTime = 0;
    lastTime = adjustTime(instance.currentTime) * (1 / anime.speed);
  }

  function seekChild(time, child) {
    if (child) {
      child.seek(time - child.timelineOffset);
    }
  }

  function syncInstanceChildren(time) {
    if (!instance.reversePlayback) {
      for (var i = 0; i < childrenLength; i++) {
        seekChild(time, children[i]);
      }
    } else {
      for (var i$1 = childrenLength; i$1--;) {
        seekChild(time, children[i$1]);
      }
    }
  }

  function setAnimationsProgress(insTime) {
    var i = 0;
    var animations = instance.animations;
    var animationsLength = animations.length;

    while (i < animationsLength) {
      var anim = animations[i];
      var animatable = anim.animatable;
      var tweens = anim.tweens;
      var tweenLength = tweens.length - 1;
      var tween = tweens[tweenLength]; // Only check for keyframes if there is more than one tween

      if (tweenLength) {
        tween = filterArray(tweens, function (t) {
          return insTime < t.end;
        })[0] || tween;
      }

      var elapsed = minMax(insTime - tween.start - tween.delay, 0, tween.duration) / tween.duration;
      var eased = isNaN(elapsed) ? 1 : tween.easing(elapsed);
      var strings = tween.to.strings;
      var round = tween.round;
      var numbers = [];
      var toNumbersLength = tween.to.numbers.length;
      var progress = void 0;

      for (var n = 0; n < toNumbersLength; n++) {
        var value = void 0;
        var toNumber = tween.to.numbers[n];
        var fromNumber = tween.from.numbers[n] || 0;

        if (!tween.isPath) {
          value = fromNumber + eased * (toNumber - fromNumber);
        } else {
          value = getPathProgress(tween.value, eased * toNumber);
        }

        if (round) {
          if (!(tween.isColor && n > 2)) {
            value = Math.round(value * round) / round;
          }
        }

        numbers.push(value);
      } // Manual Array.reduce for better performances


      var stringsLength = strings.length;

      if (!stringsLength) {
        progress = numbers[0];
      } else {
        progress = strings[0];

        for (var s = 0; s < stringsLength; s++) {
          var a = strings[s];
          var b = strings[s + 1];
          var n$1 = numbers[s];

          if (!isNaN(n$1)) {
            if (!b) {
              progress += n$1 + ' ';
            } else {
              progress += n$1 + b;
            }
          }
        }
      }

      setProgressValue[anim.type](animatable.target, anim.property, progress, animatable.transforms);
      anim.currentValue = progress;
      i++;
    }
  }

  function setCallback(cb) {
    if (instance[cb] && !instance.passThrough) {
      instance[cb](instance);
    }
  }

  function countIteration() {
    if (instance.remaining && instance.remaining !== true) {
      instance.remaining--;
    }
  }

  function setInstanceProgress(engineTime) {
    var insDuration = instance.duration;
    var insDelay = instance.delay;
    var insEndDelay = insDuration - instance.endDelay;
    var insTime = adjustTime(engineTime);
    instance.progress = minMax(insTime / insDuration * 100, 0, 100);
    instance.reversePlayback = insTime < instance.currentTime;

    if (children) {
      syncInstanceChildren(insTime);
    }

    if (!instance.began && instance.currentTime > 0) {
      instance.began = true;
      setCallback('begin');
    }

    if (!instance.loopBegan && instance.currentTime > 0) {
      instance.loopBegan = true;
      setCallback('loopBegin');
    }

    if (insTime <= insDelay && instance.currentTime !== 0) {
      setAnimationsProgress(0);
    }

    if (insTime >= insEndDelay && instance.currentTime !== insDuration || !insDuration) {
      setAnimationsProgress(insDuration);
    }

    if (insTime > insDelay && insTime < insEndDelay) {
      if (!instance.changeBegan) {
        instance.changeBegan = true;
        instance.changeCompleted = false;
        setCallback('changeBegin');
      }

      setCallback('change');
      setAnimationsProgress(insTime);
    } else {
      if (instance.changeBegan) {
        instance.changeCompleted = true;
        instance.changeBegan = false;
        setCallback('changeComplete');
      }
    }

    instance.currentTime = minMax(insTime, 0, insDuration);

    if (instance.began) {
      setCallback('update');
    }

    if (engineTime >= insDuration) {
      lastTime = 0;
      countIteration();

      if (!instance.remaining) {
        instance.paused = true;

        if (!instance.completed) {
          instance.completed = true;
          setCallback('loopComplete');
          setCallback('complete');

          if (!instance.passThrough && 'Promise' in window) {
            resolve();
            promise = makePromise(instance);
          }
        }
      } else {
        startTime = now;
        setCallback('loopComplete');
        instance.loopBegan = false;

        if (instance.direction === 'alternate') {
          toggleInstanceDirection();
        }
      }
    }
  }

  instance.reset = function () {
    var direction = instance.direction;
    instance.passThrough = false;
    instance.currentTime = 0;
    instance.progress = 0;
    instance.paused = true;
    instance.began = false;
    instance.loopBegan = false;
    instance.changeBegan = false;
    instance.completed = false;
    instance.changeCompleted = false;
    instance.reversePlayback = false;
    instance.reversed = direction === 'reverse';
    instance.remaining = instance.loop;
    children = instance.children;
    childrenLength = children.length;

    for (var i = childrenLength; i--;) {
      instance.children[i].reset();
    }

    if (instance.reversed && instance.loop !== true || direction === 'alternate' && instance.loop === 1) {
      instance.remaining++;
    }

    setAnimationsProgress(instance.reversed ? instance.duration : 0);
  }; // Set Value helper


  instance.set = function (targets, properties) {
    setTargetsValue(targets, properties);
    return instance;
  };

  instance.tick = function (t) {
    now = t;

    if (!startTime) {
      startTime = now;
    }

    setInstanceProgress((now + (lastTime - startTime)) * anime.speed);
  };

  instance.seek = function (time) {
    setInstanceProgress(adjustTime(time));
  };

  instance.pause = function () {
    instance.paused = true;
    resetTime();
  };

  instance.play = function () {
    if (!instance.paused) {
      return;
    }

    if (instance.completed) {
      instance.reset();
    }

    instance.paused = false;
    activeInstances.push(instance);
    resetTime();

    if (!raf) {
      engine();
    }
  };

  instance.reverse = function () {
    toggleInstanceDirection();
    resetTime();
  };

  instance.restart = function () {
    instance.reset();
    instance.play();
  };

  instance.reset();

  if (instance.autoplay) {
    instance.play();
  }

  return instance;
} // Remove targets from animation


function removeTargetsFromAnimations(targetsArray, animations) {
  for (var a = animations.length; a--;) {
    if (arrayContains(targetsArray, animations[a].animatable.target)) {
      animations.splice(a, 1);
    }
  }
}

function removeTargets(targets) {
  var targetsArray = parseTargets(targets);

  for (var i = activeInstances.length; i--;) {
    var instance = activeInstances[i];
    var animations = instance.animations;
    var children = instance.children;
    removeTargetsFromAnimations(targetsArray, animations);

    for (var c = children.length; c--;) {
      var child = children[c];
      var childAnimations = child.animations;
      removeTargetsFromAnimations(targetsArray, childAnimations);

      if (!childAnimations.length && !child.children.length) {
        children.splice(c, 1);
      }
    }

    if (!animations.length && !children.length) {
      instance.pause();
    }
  }
} // Stagger helpers


function stagger(val, params) {
  if (params === void 0) params = {};
  var direction = params.direction || 'normal';
  var easing = params.easing ? parseEasings(params.easing) : null;
  var grid = params.grid;
  var axis = params.axis;
  var fromIndex = params.from || 0;
  var fromFirst = fromIndex === 'first';
  var fromCenter = fromIndex === 'center';
  var fromLast = fromIndex === 'last';
  var isRange = is.arr(val);
  var val1 = isRange ? parseFloat(val[0]) : parseFloat(val);
  var val2 = isRange ? parseFloat(val[1]) : 0;
  var unit = getUnit(isRange ? val[1] : val) || 0;
  var start = params.start || 0 + (isRange ? val1 : 0);
  var values = [];
  var maxValue = 0;
  return function (el, i, t) {
    if (fromFirst) {
      fromIndex = 0;
    }

    if (fromCenter) {
      fromIndex = (t - 1) / 2;
    }

    if (fromLast) {
      fromIndex = t - 1;
    }

    if (!values.length) {
      for (var index = 0; index < t; index++) {
        if (!grid) {
          values.push(Math.abs(fromIndex - index));
        } else {
          var fromX = !fromCenter ? fromIndex % grid[0] : (grid[0] - 1) / 2;
          var fromY = !fromCenter ? Math.floor(fromIndex / grid[0]) : (grid[1] - 1) / 2;
          var toX = index % grid[0];
          var toY = Math.floor(index / grid[0]);
          var distanceX = fromX - toX;
          var distanceY = fromY - toY;
          var value = Math.sqrt(distanceX * distanceX + distanceY * distanceY);

          if (axis === 'x') {
            value = -distanceX;
          }

          if (axis === 'y') {
            value = -distanceY;
          }

          values.push(value);
        }

        maxValue = Math.max.apply(Math, values);
      }

      if (easing) {
        values = values.map(function (val) {
          return easing(val / maxValue) * maxValue;
        });
      }

      if (direction === 'reverse') {
        values = values.map(function (val) {
          return axis ? val < 0 ? val * -1 : -val : Math.abs(maxValue - val);
        });
      }
    }

    var spacing = isRange ? (val2 - val1) / maxValue : val1;
    return start + spacing * (Math.round(values[i] * 100) / 100) + unit;
  };
} // Timeline


function timeline(params) {
  if (params === void 0) params = {};
  var tl = anime(params);
  tl.duration = 0;

  tl.add = function (instanceParams, timelineOffset) {
    var tlIndex = activeInstances.indexOf(tl);
    var children = tl.children;

    if (tlIndex > -1) {
      activeInstances.splice(tlIndex, 1);
    }

    function passThrough(ins) {
      ins.passThrough = true;
    }

    for (var i = 0; i < children.length; i++) {
      passThrough(children[i]);
    }

    var insParams = mergeObjects(instanceParams, replaceObjectProps(defaultTweenSettings, params));
    insParams.targets = insParams.targets || params.targets;
    var tlDuration = tl.duration;
    insParams.autoplay = false;
    insParams.direction = tl.direction;
    insParams.timelineOffset = is.und(timelineOffset) ? tlDuration : getRelativeValue(timelineOffset, tlDuration);
    passThrough(tl);
    tl.seek(insParams.timelineOffset);
    var ins = anime(insParams);
    passThrough(ins);
    children.push(ins);
    var timings = getInstanceTimings(children, params);
    tl.delay = timings.delay;
    tl.endDelay = timings.endDelay;
    tl.duration = timings.duration;
    tl.seek(0);
    tl.reset();

    if (tl.autoplay) {
      tl.play();
    }

    return tl;
  };

  return tl;
}

anime.version = '3.1.0';
anime.speed = 1;
anime.running = activeInstances;
anime.remove = removeTargets;
anime.get = getOriginalTargetValue;
anime.set = setTargetsValue;
anime.convertPx = convertPxToUnit;
anime.path = getPath;
anime.setDashoffset = setDashoffset;
anime.stagger = stagger;
anime.timeline = timeline;
anime.easing = parseEasings;
anime.penner = penner;

anime.random = function (min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
};

let {
  assign,
  keys,
  values,
  getOwnPropertyNames
} = Object;
let {
  timeline: timeline$1,
  remove,
  stagger: stagger$1,
  random
} = anime;
let {
  isArray,
  from,
  of
} = Array; // Create an array of values that two array share in common

let _capital = val => val[0].toUpperCase() + val.slice(1); // Test the type of a value

let _is = (val, type) => typeof val == type; // Is Instance Of

let _isInst = (ctor, obj) => ctor instanceof obj;

let _type = type => {
  // Tweak of _is
  return val => _is(val, type);
};

assign(_is, {
  el: el => _isInst(el, Element) || _isInst(el, Document),

  arrlike(obj) {
    let len = _is(obj.length, "number") && obj.length;
    return len == 0 || len > 0 && len - 1 in obj;
  },

  num: val => !isNaN(val) && _type("number")(val),
  class: obj => obj && obj._method && obj._class,
  not: (type, ...args) => !_is[type](...args),
  doc: ctor => _isInst(ctor, Document),
  def: val => !_is(val, "undefined"),
  win: val => val && val.window,
  undef: _type("undefined"),
  bool: _type("boolean"),
  fn: _type("function"),
  obj: _type("object"),
  str: _type("string"),
  nul: v => v == null,
  inst: _isInst,
  arr: isArray,
  _type
});
/**
 * @param  {Function} fn
 * @param  {Array<any>} args
 * @param  {Object} ctxt
 */

let _fnval = (fn, args, ctxt) => {
  if (_is.not("fn", fn) || keys(fn.prototype || {}).length > 0) {
    return fn;
  }

  return fn.apply(ctxt, args);
};
let STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
let ARGUMENT_NAMES = /(?:^|,)\s*([^\s,=]+)/g; // Argument names

let _argNames = fn => {
  let fnStr = fn.toString().replace(STRIP_COMMENTS, '');
  let argsList = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')'));
  let result = argsList.match(ARGUMENT_NAMES),
      stripped = [];
  if (_is.nul(result)) return [];else {
    for (let i = 0; i < result.length; i++) {
      stripped.push(result[i].replace(/[\s,]/g, ''));
    }

    return stripped;
  }
}; // Get or set a value in an Object, based on it's path

let _path = (obj, path, val) => {
  path = path.toString().split(/[.,]/g);

  if (_is.def(val)) {
    if (path.length > 1) {
      _path(obj[path.shift()], path, val);
    } else {
      obj[path[0]] = val;
    }

    return val;
  } else {
    path.forEach(_val => {
      obj = obj[_val];
    });
  }

  return obj;
};
/* 
    Builds on path and adds more power, 
    * Allows for multiple paths one value
    * Using Objects as paths and setting the values individually
    * Access values as an Array, from multiple paths
*/

let _attr = (obj, path, val) => {
  if (_is.obj(path) && _is.not("arr", path)) {
    return assign(obj, path);
  } else if (_is.arr(path)) {
    if (_is.undef(val)) {
      return path.map(_key => _path(obj, _key));
    } else {
      path.forEach(_key => {
        _path(obj, _key, val);
      });
    }
  } else {
    return _path(obj, path, val);
  }

  return obj;
}; // A more efficient `new` keyword that allows for arrays to be passed as arguments

let _new = function (ctor, args) {
  let F = function () {
    return ctor.apply(this, args);
  };

  F.prototype = ctor.prototype;
  return new F();
};

// Based on Prototype.js [#class] (api.prototypejs.org/language/Class/)

let _attachProp = function (where) {
  let _prototype = where == "prototype";

  return function (_obj, ...args) {
    // If super class exists, set value of parent to `SuperClass` prototype
    let parent = _obj.SuperClass && (_prototype ? _obj.SuperClass.prototype : _obj.SuperClass);
    args.forEach(function (val) {
      // Transform functions to Objects
      let obj = _fnval(val, [_obj, _obj.constructor], _obj.prototype); // Iterate through Object


      keys(obj).forEach(function (i) {
        let _val = obj[i],
            preVal = _val; // If a Parent Class is Present, Set any argument/params named `$super` to the `Parent`

        if (_is.fn(preVal)) {
          if (parent && _argNames(preVal)[0] == "$super") {
            // Let the first argument be the original value
            _val = function (...args) {
              let parentFn = parent[i].bind(this);
              return preVal.call(this, parentFn, ...args);
            };
          } // For debugging purposes


          _val.valueOf = preVal.valueOf.bind(preVal);
          _val.toString = preVal.toString.bind(preVal);
        }

        (_prototype ? _obj.prototype : _obj)[i] = _val; // Redefinition Error Fix

        /* 
            Allows the use of `Object.defineProperty`, if an Object has any of these 
            { $$prop: true, get: function () { ... }, set: function () { ... } } 
        */

        if (_is.def(_val) && _is.obj(_val) && (_val.$$prop || _is.fn(_val.get) || _is.fn(_val.set)) && !_val._class) {
          Object.defineProperty(_prototype ? _obj.prototype : _obj, i, _val);
        }
      });
    });
    return _obj;
  };
}; // Set class prototype properties and methods

let _method = _attachProp("prototype"); // Set static properties and methods

let _static = _attachProp("static"); // Create a copy of static methods that can function as prototype methods

let _alias = function (props = {}, opts) {
  let thisArg = opts && opts.thisArg || []; // This as first argument

  let chain = opts && opts.chain || [];

  let result = {},
      _args;

  for (let i in props) {
    let val = props[i],
        toStr;

    if (_is.fn(val)) {
      // For more info: stackoverflow.com/questions/19696015
      result[i] = function (...args) {
        if (_is.fn(opts)) {
          return opts.call(this, val, ...args);
        } else {
          _args = thisArg.includes(i) ? [this, ...args] : args;

          if (chain.includes(i)) {
            val.apply(this, _args);
            return this;
          }

          return val.apply(this, _args);
        }
      };

      toStr = val.toString.bind(val);
      result[i].toString = chain.includes(i) ? () => `${toStr()} return this;` : toStr;
      result[i].valueOf = val.valueOf.bind(val);
    }
  }

  return result;
}; // Easy access to configurable property attributes, like get, set, writeable, value etc...

let _configAttr = function (attr = "get", type = "function") {
  return val => {
    let _val = val;

    if (type == "function") {
      _val = Function(`with (this) return ${val}`);
      _val.toString = val.toString;
    }

    return {
      [attr]: _val
    };
  };
}; // Get and set property attributes

let _get = _configAttr("get", "function");
let _set = _configAttr("set", "function"); // Call the parent version of a method

let _callsuper = function (obj, method, ...args) {
  let _parent = null,
      $ = obj,
      _const = $,
      _super = _const.SuperClass; // Climb prototype chain to find method not equal to callee's method

  while (_super) {
    let _method = _super.prototype[method];

    if ($[method] != _method) {
      _parent = _method;
      break;
    }

    $ = _super.prototype;
    _const = $.constructor;
    _super = _const.SuperClass;
  }

  if (!_parent) {
    console.error(`${method} method not found in prototype chain.`);
    return;
  }

  return _parent.apply(obj, args);
}; // All properties with the ability to use this as a first Argument

let _thisArgs = {
  fnval: _fnval,
  argNames: _argNames,
  method: _method,
  static: _static,
  path: _path,
  attr: _attr,
  alias: _alias,
  new: _new,
  callsuper: _callsuper
};
let props = {
  _is,
  _fnval,
  _argNames,
  _method,
  _static,
  _path,
  _attr,
  _alias,
  _configAttr,
  _get,
  _set,
  _new,
  _callsuper,
  assign,
  keys
};
props = keys(props).reduce(function (acc, i) {
  i.charAt(0) == "_" && (acc[i.slice(1)] = props[i]);
  return acc;
}, props); // Properties methods with Class support

let aliasMethods = _alias(_thisArgs, function (val, ...args) {
  let _val = val.apply(this, [this, ...args]);

  return _val;
}); // Create classes

let _create = function (...args) {
  let $class, subclass, parent, extend; // SubClass constructor

  subclass = function () {}; // Set parent constructor


  if (_is.fn(args[0]) && keys(args[0].prototype || {}).length) {
    parent = args.shift();
  } // Class Object


  $class = function (..._args) {
    // Current Class
    if (!_is.inst(this, $class)) {
      return _new($class, _args);
    }

    this._args = _args; // Arguments
    // Initialize Class

    return this.init.apply(this, this._args);
  };

  $class.SuperClass = parent; // Current Class's Parent if any

  $class.SubClasses = []; // List of SubClasses
  // Extend parent class, if any

  if (parent) {
    subclass.prototype = parent.prototype;
    $class.prototype = new subclass();
    if (!_is.arr(parent.SubClasses)) parent.SubClasses = [];
    parent.SubClasses.push($class);
  } // Easily extend this class to create new subclasses


  extend = function (...args) {
    return _create.call(this, this, ...args);
  }; // Extend Class


  assign($class, aliasMethods, {
    extend,
    create: _create
  });
  assign($class.prototype, $class); // Add Methods to Class

  $class.method(...args); // Set Current class type

  if (!$class.prototype._class) {
    $class.prototype._class = "New Class";
  }

  if (!$class.prototype.init) {
    $class.prototype.init = function () {};
  } else {
    // Set toString & toValue
    $class.toString = $class.prototype.init.toString;
    $class.toValue = $class.prototype.init.toValue;
  } // Set Class constructor


  $class.prototype.constructor = $class;
  return $class;
}; // Create classes

let _class = _create;
assign(_class, props); // Extend _class

/**
 * @function getReferenceKey
 *
 * @description
 * get the reference key for the circular value
 *
 * @param keys the keys to build the reference key from
 * @param cutoff the maximum number of keys to include
 * @returns the reference key
 */
function getReferenceKey(keys, cutoff) {
  return keys.slice(0, cutoff).join('.') || '.';
}
/**
 * @function getCutoff
 *
 * @description
 * faster `Array.prototype.indexOf` implementation build for slicing / splicing
 *
 * @param array the array to match the value in
 * @param value the value to match
 * @returns the matching index, or -1
 */


function getCutoff(array, value) {
  var length = array.length;

  for (var index = 0; index < length; ++index) {
    if (array[index] === value) {
      return index + 1;
    }
  }

  return 0;
}
/**
 * @function createReplacer
 *
 * @description
 * create a replacer method that handles circular values
 *
 * @param [replacer] a custom replacer to use for non-circular values
 * @param [circularReplacer] a custom replacer to use for circular methods
 * @returns the value to stringify
 */


function createReplacer(replacer, circularReplacer) {
  var hasReplacer = typeof replacer === 'function';
  var hasCircularReplacer = typeof circularReplacer === 'function';
  var cache = [];
  var keys = [];
  return function replace(key, value) {
    if (typeof value === 'object') {
      if (cache.length) {
        var thisCutoff = getCutoff(cache, this);

        if (thisCutoff === 0) {
          cache[cache.length] = this;
        } else {
          cache.splice(thisCutoff);
          keys.splice(thisCutoff);
        }

        keys[keys.length] = key;
        var valueCutoff = getCutoff(cache, value);

        if (valueCutoff !== 0) {
          return hasCircularReplacer ? circularReplacer.call(this, key, value, getReferenceKey(keys, valueCutoff)) : "[ref=" + getReferenceKey(keys, valueCutoff) + "]";
        }
      } else {
        cache[0] = value;
        keys[0] = key;
      }
    }

    return hasReplacer ? replacer.call(this, key, value) : value;
  };
}
/**
 * @function stringify
 *
 * @description
 * strinigifer that handles circular values
 *
 * @param the value to stringify
 * @param [replacer] a custom replacer function for handling standard values
 * @param [indent] the number of spaces to indent the output by
 * @param [circularReplacer] a custom replacer function for handling circular values
 * @returns the stringified output
 */


function stringify(value, replacer, indent, circularReplacer) {
  return JSON.stringify(value, createReplacer(replacer, circularReplacer), indent);
}

var index_esm = /*#__PURE__*/Object.freeze({
  'default': stringify
});

function getCjsExportFromNamespace (n) {
	return n && n['default'] || n;
}

var stringify$1 = getCjsExportFromNamespace(index_esm);

let _stringify = obj => {
  let fns = [];
  let json = stringify$1(obj, (key, val) => {
    if (typeof val == "function") {
      fns.push(val.toString());
      return "_";
    }

    return val;
  }, 4);
  return json.replace(/"_"/g, () => fns.shift());
};

var stringify_1 = {
  stringify: stringify$1,
  _stringify
};
var stringify_3 = stringify_1._stringify;

const {
  _get: _get$1,
  _is: _is$1,
  _argNames: _argNames$1,
  keys: keys$1
} = _class;
const {
  readyState
} = document; // Test for passive support, based on [github.com/rafrex/detect-passive-events]

let passive = false,
    opts = {},
    noop = () => {};

opts = Object.defineProperty({}, "passive", {
  get: () => passive = {
    capture: false,
    passive: true
  }
});
window.addEventListener("PassiveEventTest", noop, opts);
window.removeEventListener("PassiveEventsTest", noop, opts); // Event class

let _event = _class({
  _class: "Event",
  // Class name
  _events: {},
  // Event info.
  _emit: [],
  // Store events set to be emitted
  // Name of all event's
  _names: _get$1("Object.keys(_events)"),
  // Number of events
  _eventCount: _get$1("_names.length"),

  // Prepare the event
  _preEvent(evt) {
    if (!this._events[evt]) // List of event's
      {
        this._events[evt] = [];
      }

    return this._events[evt];
  },

  // Apply event as object
  _eventApp(callback, scope, event) {
    return {
      callback: callback,
      scope: scope || this,
      event: event
    };
  },

  // Add a listener for a given event
  on(evt, callback, scope) {
    let $EvtApp, $evt;

    if (_is$1.undef(evt)) {
      return;
    } // If there is no event break


    if (_is$1.str(evt)) {
      evt = evt.split(/\s/g);
    }

    if (_is$1.not("arr", evt) && _is$1.not("obj", evt)) {
      evt = [evt];
    } // Set evt to an array
    // Loop through the list of events 


    keys$1(evt).forEach(function (key) {
      $evt = evt[key];

      if (_is$1.obj(evt) && _is$1.not("arr", evt)) {
        $EvtApp = this._eventApp($evt, callback || this, key);

        this._preEvent(key).push($EvtApp); // Set event list

      } else {
        $EvtApp = this._eventApp(callback, scope, $evt);

        this._preEvent($evt).push($EvtApp); // Set event list

      }
    }, this);
    return this;
  },

  // Call all function(s) within an event
  emit(evt, ...args) {
    let $Evt,
        $args = args;

    if (_is$1.undef(evt)) {
      return;
    } // If there is no event break


    if (_is$1.str(evt)) {
      evt = evt.split(/\s/g);
    }

    if (_is$1.not("arr", evt)) {
      evt = [evt];
    } // Set evt to an array
    // Loop through the list of events 


    evt.forEach(function ($evt) {
      $Evt = this._preEvent($evt);

      if (!this._emit.includes($evt)) {
        this._emit.push($evt);
      }

      $Evt.forEach(_evt => {
        $args = args;

        if (_argNames$1(_evt.callback)[0] == "$evt") {
          $args = [_evt, ...args];
        }

        _evt.callback.apply(_evt.scope, $args);
      }, this);
    }, this);
    return this;
  },

  // Removes a listener for a given event
  off(evt, callback, scope) {
    let $evt;

    if (_is$1.undef(evt)) {
      return;
    } // If there is no event break


    if (_is$1.str(evt)) {
      evt = evt.split(/\s/g);
    }

    if (_is$1.not("arr", evt) && _is$1.not("obj", evt)) {
      evt = [evt];
    } // Set evt to an array


    let _off = function ($evt, callback, scope) {
      let _Evt = this._preEvent($evt);

      if (callback) {
        let i,
            app = this._eventApp(callback, scope || this, $evt);

        _Evt.forEach((val, _i) => {
          if (stringify_3(val) == stringify_3(app)) {
            i = _i;
          }
        }, this);

        if (i > -1) {
          _Evt.splice(i, 1);
        }
      } else {
        delete this._events[$evt];
      }
    }.bind(this);

    keys$1(evt).forEach(function (key) {
      $evt = evt[key];

      if (_is$1.obj(evt) && _is$1.not("obj", evt)) {
        _off(key, $evt, scope);
      } else {
        _off($evt, callback, scope);
      }
    }, this);
    return this;
  },

  // Adds a one time event listener for a given event
  once(evt, callback, scope) {
    if (_is$1.undef(evt)) {
      return;
    } // If there is no event break


    if (_is$1.str(evt)) {
      evt = evt.split(/\s/g);
    }

    if (_is$1.not("arr", evt) && _is$1.not("obj", evt)) {
      evt = [evt];
    } // Set evt to an array


    let $Fn = function (...args) {
      this.off(evt, $Fn, scope);
      callback.apply(scope, args);
    };

    this.on(evt, $Fn, scope);
    return this;
  },

  // List's all listeners for a given event
  listeners(evt) {
    let $Evt = this._preEvent(evt);

    if (!$Evt.length) {
      return [];
    }

    return $Evt.map(val => val.callback);
  },

  // List's all listener values for a given event
  listenerValues(evt, ...args) {
    let $Evt = this._preEvent(evt);

    if (!$Evt.length) {
      return [];
    }

    return $Evt.map(val => val.callback.call(val.scope, ...args));
  },

  // Clear all events
  clear() {
    this._eventCount = 0;
    this._events = {};
    return this;
  },

  // Clear all events
  clearListeners(evt) {
    this._events[evt] = [];
    return this;
  },

  // Alias for the `on` method
  add: _get$1("on"),
  bind: _get$1("on"),
  // Alias for the `off` method
  remove: _get$1("off"),
  unbind: _get$1("off"),
  // Alias for the `emit` method
  fire: _get$1("emit"),
  trigger: _get$1("emit"),
  // Alias for the `listeners` method
  callbacks: _get$1("listeners")
}).static({
  nativeEvents: `ready load blur focus focusin focusout resize click scroll dblclick 
    mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave 
    change select submit keydown keypress keyup contextmenu`.split(" "),

  applyNative(evt, el, ev, i, action = "addEventListener") {
    if (!ev.length) return;

    let _emit = _ev => e => evt.emit(_ev, e, evt, i);

    if (/ready|load/.test(ev)) {
      if (!/in/.test(readyState)) {
        _emit("ready load")();
      } else if (document.addEventListener) {
        document.addEventListener('DOMContentLoaded', _emit("ready load"));
      } else {
        document.attachEvent('onreadystatechange', e => {
          if (!/in/.test(readyState)) _emit("ready load")(e);
        });
      }
    } else {
      ev.split(" ").forEach(val => {
        el[action](val, _emit(ev), ev == "scroll" ? passive : {});
      });
    }
  }

});

const {
  createElement,
  documentElement
} = document;
let Ele;
let tagRE = /^\s*<(\w+|!)[^>]*>/;
let {
  applyNative,
  nativeEvents
} = _event;
let tagExpandRE = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig;
let _cssNumber = ["column-count", "columns", "font-weight", "line-height", "opacity", "z-index", "zoom"];

let _qsa = (dom = document, sel) => {
  let classes;
  if (!_is.str(sel) && sel.length == 0) return [];

  if (/^(#?[\w-]+|\.[\w-.]+)$/.test(sel)) {
    switch (sel.charAt(0)) {
      case '#':
        return [dom.getElementById(sel.substr(1))];

      case '.':
        classes = sel.substr(1).replace(/\./g, ' ');
        return [...dom.getElementsByClassName(classes)];

      default:
        return [...dom.getElementsByTagName(sel)];
    }
  }

  return [...dom.querySelectorAll(sel)];
}; // The matches() method checks to see if the Element would be selected by the provided selectorString -- in other words -- checks if the element "is" the selector.


let _matches = (ele, sel) => {
  let matchSel = ele.matches || ele.msMatchesSelector || ele.webkitMatchesSelector;
  if (matchSel) return matchSel.call(ele, sel);
}; // Check if the parent node contains the given DOM node. Returns false if both are the same node.


let _contains = (parent, node) => {
  if (parent.contains) return parent != node && parent.contains(node);

  while (node && (node = node.parentNode)) if (node == parent) return true;

  return false;
}; // Support the Element Object as an Array


let _toArr = val => _is.inst(val, Ele) ? val.toArray() : val;

let _concat = function (args) {
  [].map.call(args, val => _toArr(val));
  return [].concat.apply(_toArr(this), args);
}; // Create a flat Array


let _flatten = arr => arr.length > 0 ? _concat.apply([], arr) : arr; // Map Objects


let _map = (obj, fn, ctxt) => {
  return _flatten([].map.call(obj, fn, ctxt).filter(item => _is.def(item)));
}; // Select all children of an element


let _children = el => {
  return 'children' in el ? [].slice.call(el.children) : _map(el.childNodes, node => {
    if (node.nodeType == 1) return node;
  });
}; // Class name cache


let _cache = {}; // Get the class name for an Element

let _getclass = function classNme(node, value) {
  let name = node.className || '';
  let svg = name && !_is.undef(name.baseVal);
  if (_is.undef(value)) return svg ? name.baseVal : name;
  svg ? name.baseVal = value : node.className = value;
}; // Class name RegExp


let _classRE = name => {
  return name in _cache ? _cache[name] : _cache[name] = new RegExp('(^|\\s)' + name + '(\\s|$)');
}; // Create an Element List from a HTML string


let _createElem = html => {
  let dom, container;
  container = createElement('div');
  container.innerHTML = '' + html.replace(tagExpandRE, "<$1></$2>");
  dom = [].slice.call(container.childNodes);
  dom.forEach(el => {
    container.removeChild(el);
  });
  return dom;
}; // Element selector


let _elem = (sel, ctxt) => {
  if (_is.str(sel)) {
    sel = sel.trim();

    if (tagRE.test(sel)) {
      return _createElem(sel);
    } else {
      return _qsa(ctxt, sel);
    }
  } else if (_is.inst(sel, Ele)) {
    return sel.ele;
  } else if (_is.arr(sel) || _is.inst(sel, NodeList)) {
    return [...sel].filter(item => _is.def(item));
  } else if (_is.obj(sel) || _is.el(sel)) {
    return [sel];
  } else if (_is.fn(sel)) {
    Ele(document).ready(sel);
  }

  return [];
}; // Traverse DOM Depth First


let traverseDF = (_node, fn, childType = "childNodes") => {
  let recurse; // This is a recurse and immediately-invoking function

  recurse = node => {
    // Step 2
    node[childType] && node[childType].forEach(recurse, node); // Step 3

    fn.call(node, node); // Step 4
  };

  recurse(_node); // Step 1
}; // Quickly filter nodes by a selector 


let _filter = (nodes, sel) => !_is.def(sel) ? Ele(nodes) : Ele(nodes).filter(sel); // Select all the different values in an Array, based on underscorejs


let _uniq = arr => {
  return [].filter.call(arr, (val, idx) => arr.indexOf(val) == idx);
}; // Quickly set the value of an attribute or remove the attribute completely from a node


let _setAttr = (node, name, value) => value == null ? node.removeAttribute(name) : node.setAttribute(name, value); // Transform  string value to the proper type of value eg. "12" = 12, "[12, 'xyz']" = [12, 'xyz']


let _valfix = value => {
  let validTypes = /^true|false|null|undefined|\d+$/;

  let _fn = v => Function(`"use strict"; return ${v};`)();

  let objectType = /^[[{]([\s\S]+)?[\]}]$/;

  try {
    return validTypes.test(value) ? _fn(value) : objectType.test(value) ? JSON.parse(value.replace(/'/g, "\"")) : value;
  } catch (e) {
    return value;
  }
}; // Decide if the value deserves px at the 


let _maybeAddPx = (name, val) => {
  return _is.num(+val) && !_cssNumber.includes(name) ? `${val}px` : val;
}; // Allow default Array methods to work as Element Object methods


let arrProto = getOwnPropertyNames(Array.prototype).reduce(function (acc, i) {
  acc[i] = function (...args) {
    let _val = Array.prototype[i].apply(this, args);

    return _is.undef(_val) ? this : _val;
  };

  return acc;
}, {}); // Element Object [Based on Zepto.js]

Ele = _event.extend(arrProto, {
  init(sel = '', ctxt) {
    this.sel = sel; // Selector

    this.ele = _elem(this.sel, ctxt); // Element

    for (let i = 0; i < this.length; i++) this[i] = this.ele[i];
  },

  slice(...args) {
    return Ele([].slice.apply(this, args));
  },

  map(fn) {
    return Ele(_map(this, (el, i) => fn.call(el, el, i), this));
  },

  on($super, evt, callback, scope) {
    let _newEvts, _evt;

    if (_is.undef(evt)) {
      return;
    } // If there is no event break


    if (_is.str(evt)) {
      evt = evt.split(/\s/g);
    }

    if (_is.not("arr", evt) && _is.not("obj", evt)) {
      evt = [evt];
    } // Set evt to an array


    _evt = _is.obj(evt) && _is.not("arr", evt) ? keys(evt) : evt;
    _newEvts = _evt.filter(val => !(val in this._events), this).join(" ");
    this.forEach(function (el, i) {
      $super(evt, callback, scope || el);
      applyNative(this, el, _newEvts, i);
    }, this);
    return this;
  },

  off($super, evt, callback, scope) {
    let _evt;

    if (_is.undef(evt)) {
      return;
    } // If there is no event break


    if (_is.str(evt)) {
      evt = evt.split(/\s/g);
    }

    if (_is.not("arr", evt) && _is.not("obj", evt)) {
      evt = [evt];
    } // Set evt to an array


    _evt = (_is.obj(evt) && _is.not("arr", evt) ? keys(evt) : evt).join(" ");
    this.forEach(function (el, i) {
      $super(evt, callback, scope || el);
      applyNative(this, el, _evt, i, "removeEventListener");
    }, this);
    return this;
  },

  length: _get("len"),
  len: _get("ele.length"),

  each(fn) {
    [].every.call(this, function (el, idx) {
      return fn.call(el, el, idx) != false;
    });
    return this;
  },

  get(idx) {
    return _is.undef(idx) ? [].slice.call(this) : this[idx >= 0 ? idx : idx + this.length];
  },

  nth: _get("get"),

  size() {
    return this.length;
  },

  toArray() {
    return this.get();
  },

  remove() {
    return this.each(el => {
      if (_is.def(el.parentNode)) ;
      el.parentNode.removeChild(el);
    });
  },

  not(sel) {
    let excludes,
        $this = this;
    return Ele(this.reduce(function (acc, el, idx) {
      if (_is.fn(sel) && _is.def(sel.call)) {
        if (!sel.call(el, el, idx)) acc.push(el);
      } else {
        excludes = _is.str(sel) ? $this.filter(sel) : _is.arrlike(sel) && _is.fn(sel.item) ? [].slice.call(sel) : Ele(sel);
        if (excludes.indexOf(el) < 0) acc.push(el);
      }

      return acc;
    }, [], this));
  },

  filter(sel) {
    if (_is.fn(sel)) return this.not(this.not(sel));
    return [].filter.call(this, ele => _matches(ele, sel), this);
  },

  has(sel) {
    return this.filter(el => {
      return _is.obj(sel) ? _contains(el, sel) : Ele(el).find(sel).size();
    });
  },

  eq(idx) {
    return idx == -1 ? this.slice(idx) : this.slice(idx, +idx + 1);
  },

  first() {
    let el = this.get(0);
    return el && !_is.obj(el) ? el : Ele(el);
  },

  last() {
    let el = this.get(-1);
    return el && !_is.obj(el) ? el : Ele(el);
  },

  find(sel) {
    let result,
        $this = this;
    if (!sel) result = Ele();else if (_is.obj(sel)) {
      result = Ele(sel).filter(el => {
        return [].some.call($this, parent => _contains(parent, el));
      });
    } else if (this.length == 1) {
      result = Ele(_qsa(this.get(0), sel));
    } else {
      result = this.map(el => _qsa(el, sel));
    }
    return result;
  },

  closest(sel, ctxt) {
    let list = _is.obj(sel) && Ele(sel);
    return Ele(this.reduce((acc, ele) => {
      do {
        if (list ? list.indexOf(ele) >= 0 : _matches(ele, sel)) break;
        ele = ele != ctxt && _is.not("doc", ele) && ele.parentNode;
      } while (ele !== null && ele.nodeType === 1);

      if (ele && acc.indexOf(ele) < 0) acc.push(ele);
      return acc;
    }, []));
  },

  parents(sel) {
    let ancestors = [],
        nodes = this;

    while (nodes.length > 0) {
      nodes = nodes.map(el => {
        if ((el = el.parentNode) && !_is.doc(el) && ancestors.indexOf(el) < 0) {
          ancestors.push(el);
          return el;
        }
      });
    }

    return _filter(ancestors, sel);
  },

  // `pluck` based on underscore.js, but way more powerful
  pluck(prop) {
    return this.map(el => _path(el, prop));
  },

  parent(sel) {
    return _filter(_uniq(this.pluck('parentNode')), sel);
  },

  children(sel) {
    return _filter(this.map(el => _children(el)), sel);
  },

  contents() {
    return this.map(el => el.contentDocument || [].slice.call(el.childNodes));
  },

  siblings(sel) {
    return _filter(this.map(el => [].filter.call(_children(el.parentNode), child => child != el)), sel);
  },

  replaceWith: content => undefined.before(content).remove(),
  clone: () => undefined.map(el => el.cloneNode(true)),

  toggle(opt) {
    return this.each(el => {
      let _el = Ele(el);

      let _opt = opt || el.style("display") == "none";

      _el[_opt ? "show" : "hide"]();
    });
  },

  prev: sel => Ele(undefined.pluck('previousElementSibling')).filter(sel || '*'),
  next: sel => Ele(undefined.pluck('nextElementSibling')).filter(sel || '*'),

  html(...args) {
    let [html] = args;
    return args.length ? this.each((el, idx) => {
      let originHTML = el.innerHTML;
      Ele(el).empty().append(_fnval(html, [idx, originHTML], el));
    }) : this.length ? this.get(0).innerHTML : null;
  },

  text(...args) {
    let [text] = args;
    return args.length ? this.each((el, idx) => {
      let newText = _fnval(text, [idx, el.textContent], el);

      el.textContent = _is.nul(newText) ? '' : `${newText}`;
    }) : this.length ? this.pluck('textContent').join("") : null;
  },

  attr(name, val) {
    let result;

    if (_is.str(name) && _is.undef(val)) {
      result = this.length && this.get(0).nodeType == 1 && this.get(0).getAttribute(name);
      return !_is.nul(result) ? result : undefined;
    } else {
      return this.each((el, idx) => {
        if (el.nodeType != 1) return;

        if (_is.arr(name)) {
          for (let i in name) _setAttr(el, i, name[i]);
        } else {
          _setAttr(el, name, _fnval(val, [idx, el.getAttribute(name)], el));
        }
      });
    }
  },

  removeAttr(name) {
    return this.each(el => {
      el.nodeType == 1 && name.split(' ').forEach(attr => {
        _setAttr(el, attr);
      });
    });
  },

  data(name, value) {
    let attrName = `data-${name}`.toLowerCase();
    let data = _is.def(value) ? this.attr(attrName, value) : this.attr(attrName);
    return data != null ? _valfix(data) : undefined;
  },

  val(...args) {
    let [value] = args,
        _el;

    if (args.length) {
      if (_is.nul(value)) value = "";
      return this.each((el, idx) => {
        el.value = _fnval(value, [idx, el.value], el);
      });
    } else {
      _el = this.get(0);
      return _el && (_el.multiple ? Ele(_el).find('option').filter(el => el.selected).pluck('value') : _el.value);
    }
  },

  offset(coords) {
    let obj;

    if (coords) {
      return this.each((el, idx) => {
        let $this = Ele(el);

        let _coords = _fnval(coords, [idx, $this.offset()], el);

        let parentOffset = $this.offsetParent().offset();
        let props = {
          top: _coords.top - parentOffset.top,
          left: _coords.left - parentOffset.left
        };
        if ($this.style('position') == 'static') props.position = 'relative';
        $this.style(props);
      });
    }

    if (!this.length) return null;
    if (documentElement != this.get(0) && !_contains(documentElement, this.get(0))) return {
      top: 0,
      left: 0
    };
    obj = this.get(0).getBoundingClientRect();
    return {
      left: obj.left + window.pageXOffset,
      top: obj.top + window.pageYOffset,
      width: Math.round(obj.width),
      height: Math.round(obj.height)
    };
  },

  style(...args) {
    let [prop, val] = args,
        css = '',
        key;

    if (args.length < 2) {
      let el = this.get(0);
      if (!el) return;

      if (_is.str(prop)) {
        return el.style[prop] || window.getComputedStyle(el, '').getPropertyValue(prop);
      } else if (_is.arr(prop)) {
        let props = {};
        let computedStyle = window.getComputedStyle(el, '');
        prop.forEach(_prop => {
          props[_prop] = el.style[_prop] || computedStyle.getPropertyValue(_prop);
        });
        return props;
      }
    }

    if (_is.str(prop)) {
      if (!val && val != 0) {
        this.each(el => {
          el.style.removeProperty(prop);
        });
      } else {
        css = prop + ":" + _maybeAddPx(prop, val);
      }
    } else {
      for (key in prop) {
        if (!prop[key] && prop[key] != 0) {
          this.each(el => {
            el.style.removeProperty(key);
          });
        } else {
          css += key + ':' + _maybeAddPx(key, prop[key]) + ';';
        }
      }
    }

    return this.each(el => {
      el.style.cssText += ';' + css;
    });
  },

  show: () => undefined.style("display", ""),
  hide: () => undefined.style("display", "none"),
  empty: () => undefined.each(el => {
    el.innerHTML = '';
  }),

  index(el) {
    return el ? this.indexOf(Ele(el).get(0)) : this.parent().children().indexOf(this.get(0));
  },

  hasClass(name) {
    if (!name) return false;
    return [].some.call(this, function (el) {
      return this.test(_getclass(el));
    }, _classRE(name));
  },

  addClass(name) {
    if (!name) return this;
    return this.each(function (el, idx) {
      if (!('className' in el)) return;

      let classList = [],
          cls = _getclass(el);

      _fnval(name, [idx, cls], el).split(/\s+/g).forEach(function (_name) {
        if (!Ele(this).hasClass(_name)) classList.push(_name);
      }, el);

      classList.length && _getclass(el, cls + (cls ? " " : "") + classList.join(" "));
    });
  },

  removeClass(name) {
    return this.each(function (el, idx) {
      if (!('className' in el)) return;
      if (_is.undef(name)) return _getclass(el, '');

      let classList = _getclass(el);

      _fnval(name, [idx, classList], el).split(/\s+/g).forEach(function (_name) {
        classList = classList.replace(_classRE(_name), " ");
      });

      _getclass(el, classList.trim());
    });
  },

  toggleClass(name, when) {
    if (!name) return this;
    return this.each(function (el, idx) {
      let $this = Ele(el);

      _fnval(name, [idx, _getclass(el)], el).split(/\s+/g).forEach(function (_name) {
        (_is.undef(when) ? !$this.hasClass(_name) : when) ? $this.addClass(_name) : $this.removeClass(_name);
      });
    });
  },

  scrollTop(val) {
    if (!this.length) return;
    let hasScroll = 'scrollTop' in this.get(0);
    if (_is.undef(val)) return this.get(0)[hasScroll ? "scrollTop" : "pageYOffset"];
    return this.each(function () {
      hasScroll ? this.scrollTop = val : this.scrollTo(this.scrollX, val);
    });
  },

  scrollLeft(val) {
    if (!this.length) return;
    let hasScroll = 'scrollLeft' in this.get(0);
    if (_is.undef(val)) return this.get(0)[hasScroll ? "scrollLeft" : "pageXOffset"];
    return this.each(function () {
      hasScroll ? this.scrollLeft = val : this.scrollTo(val, this.scrollY);
    });
  },

  offsetParent() {
    return this.map(function (el) {
      let parent = el.offsetParent || document.body;

      while (parent && !/^(?:body|html)$/i.test(parent.nodeName) && Ele(parent).style("position") == "static") parent = parent.offsetParent;

      return parent;
    });
  },

  position() {
    if (!this.length) return;
    let elem = this.get(0),
        offsetParent = this.offsetParent(),
        offset = this.offset(),
        parentOffset = /^(?:body|html)$/i.test(offsetParent[0].nodeName) ? {
      top: 0,
      left: 0
    } : offsetParent.offset();
    offset.top -= parseFloat(Ele(elem).style('margin-top')) || 0;
    offset.left -= parseFloat(Ele(elem).style('margin-left')) || 0;
    parentOffset.top += parseFloat(Ele(offsetParent[0]).style('border-top-width')) || 0;
    parentOffset.left += parseFloat(Ele(offsetParent[0]).style('border-left-width')) || 0;
    return {
      top: offset.top - parentOffset.top,
      left: offset.left - parentOffset.left
    };
  },

  getAnime() {
    return this.timeline;
  },

  animate(opt = {}, offset) {
    opt = _fnval(opt, [{
      stagger: stagger$1,
      remove,
      random
    }, offset], this);

    if (_is.undef(this.timeline)) {
      this.timeline = timeline$1({
        targets: _toArr(this)
      });
    }

    let {
      play,
      ...opts
    } = opt;
    let tl = this.timeline;
    tl.add(opts, offset);
    _is.def(play) && (play && tl.play() || tl.pause());
    return this;
  }

}, // Generate shortforms for events eg. .click(), .hover(), etc... 
nativeEvents.reduce((acc, name) => {
  // Handle event binding
  acc[name] = function (...args) {
    return this.on(name, ...args);
  };

  return acc;
}, {
  hover(fnOver, fnOut) {
    return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
  }

}), // Generate the `width` and `height` methods
['width', 'height'].reduce((acc, sz) => {
  let prop = _capital(sz);

  acc[sz] = function (value) {
    let offset,
        el = this.get(0);

    if (_is.undef(value)) {
      if (_is.win(el)) {
        return el[`inner${prop}`];
      } else if (_is.doc(el)) {
        return el.documentElement[`scroll${prop}`];
      } else {
        return (offset = this.offset()) && offset[sz];
      }
    } else {
      return this.each((_el, idx) => {
        el = Ele(_el);
        el.style(sz, _fnval(value, [idx, el[sz]()], _el));
      });
    }
  };

  return acc;
}, {}), // Generate the `after`, `prepend`, `before`, `append`, `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.
['after', 'prepend', 'before', 'append'].reduce(function (acc, fn, idx) {
  let inside = idx % 2; //=> prepend, append

  acc[fn] = function (...args) {
    // Arguments can be nodes, arrays of nodes, Element objects and HTML strings
    let clone = this.length > 1;

    let nodes = _map(args, function (arg) {
      if (_is.arr(arg)) {
        return arg.reduce((acc, el) => {
          if (_is.def(el.nodeType)) acc.push(el);else if (_is.inst(el, Ele)) acc = acc.concat(el.get());else if (_is.str(el)) acc = acc.concat(_createElem(el));
          return acc;
        }, []);
      }

      return _is.obj(arg) || _is.nul(arg) ? arg : _createElem(arg);
    });

    return this.each(function (target) {
      let parent = inside ? target : target.parentNode;

      let parentInDoc = _contains(documentElement, parent);

      let next = target.nextSibling,
          first = target.firstChild; // Convert all methods to a "before" operation

      target = [next, first, target, null][idx];
      nodes.forEach(function (node) {
        if (clone) node = node.cloneNode(true);else if (!parent) return Ele(node).remove();
        parent.insertBefore(node, target);

        if (parentInDoc) {
          traverseDF(node, function (el) {
            if (!_is.nul(el.nodeName) && el.nodeName.toUpperCase() == 'SCRIPT' && (!el.type || el.type == 'text/javascript') && !el.src) {
              let target = el.ownerDocument ? el.ownerDocument.defaultView : window;
              target.eval.call(target, el.innerHTML);
            }
          });
        }
      });
    });
  }; // after    => insertAfter, prepend  => prependTo
  // before   => insertBefore, append   => appendTo


  acc[inside ? `${fn}To` : `insert${_capital(fn)}`] = function (html) {
    Ele(html)[fn](this);
    return this;
  };

  return acc;
}, {})).static({
  children,
  define,
  html,
  parent,
  property,
  render
}); // hybrids
var el = Ele;

// import swup from "swup";
// import './components/smoothstate';
// import _class from "./components/class";
// import _event from "./components/event";
// import scrollPlugin from "@swup/scroll-plugin";
// import slideTheme from '@swup/slide-theme';
// import preload from '@swup/preload-plugin';
// let _load = () => { };

let _log = (...args) => args.forEach(v => console.log(v));

let ele = el(`<a class='Name'>Hello</a>`);
ele.prependTo("#swup");
ele.on("click", function () {
  _log(this);

  el(this).animate({
    color: "#ffeeaa",
    translateX: 250
  });
});
el('main').find(`a.Name`).on("click mouseenter", () => {
  // e.preventDefault();
  _log("Name");
});
el(function () {
  let $ = window.jQuery; // let _body = 

  let opts = {
    debug: true,
    prefetch: true,
    cacheLength: 4,
    onStart: {
      duration: 350,
      // Duration of our animation
      render: function ($container) {
        // Add your CSS animation reversing class
        $container.addClass('is-animating'); // Restart your animation

        smoothState.restartCSSAnimations();
      }
    },
    onReady: {
      duration: 0,
      render: function ($container, $newContent) {
        // Remove your CSS animation reversing class
        $container.removeClass('is-animating'); // Inject the new content

        $container.html($newContent);
      }
    }
  },
      smoothState = $("#swup").smoothState(opts).data('smoothState');
  $(".navbar").on("click", "a[href^='/']", function (e) {
    e.preventDefault();
    smoothState.load($(this).attr("href"));
  });
  $(".navbar").on("hover", "a[href^='/']", function (e) {
    e.preventDefault();
    smoothState.fetch($(this).attr("href"));
  }); // 
});
/*
el('main').on('click', '[data-type="page-transition"]', function(event){
   event.preventDefault();
   //detect which page has been selected
   var newPage = el(this).attr('href');
   //if the page is not animating - trigger animation
   if( !isAnimating ) changePage(newPage, true);
});
function changePage(url, bool) {
   isAnimating = true;
   // trigger page animation
   $('body').addClass('page-is-changing');
   //...
   loadNewContent(url, bool);
   //...
}
function loadNewContent(url, bool) {
   var newSectionName = 'cd-'+url.replace('.html', ''),
   section = $('<div class="cd-main-content '+newSectionName+'"></div>');
   section.load(url+' .cd-main-content > *', function(event){
      // load new content and replace <main> content with the new one
      $('main').html(section);
      //...
      $('body').removeClass('page-is-changing');
      //...

      if(url != window.location){
         //add the new page to the window.history
         window.history.pushState({path: url},'',url);
      }
   });
}
$(window).on('popstate', function() {
   var newPageArray = location.pathname.split('/'),
   //this is the url of the page to be loaded 
   newPage = newPageArray[newPageArray.length - 1];
   if( !isAnimating ) changePage(newPage);
});
*/

/* let trans = new swup({
	requestHeaders: {
		"X-Requested-With": "swup", // So we can tell request comes from swup
		"x-partial": "swup" // Request a partial html page
	},
	plugins: [new preload()]
});

_load();

// this event runs for every page view after initial load
trans.on('contentReplaced', _load); */

//# sourceMappingURL=../maps/app.modern.min.js.map
